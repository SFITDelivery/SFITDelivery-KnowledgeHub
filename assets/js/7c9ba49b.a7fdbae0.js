"use strict";(self.webpackChunksfit_delivery_knowledge_hub=self.webpackChunksfit_delivery_knowledge_hub||[]).push([[3320],{7239:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=t(5893),i=t(1151);const a={sidebar_position:5,title:"Destructive Change",tags:["Managment","Deployment","Destructive Change"]},o=void 0,r={id:"Management/02_03_Deployment/02_03_05_Destructive_Change",title:"Destructive Change",description:"Destructive Changes refer to the process of removing outdated metadata (such as fields, objects, classes, pages, and other components) that are no longer needed in the target environment. This is important for maintaining system cleanliness and improving performance, as it helps eliminate unused or outdated components.",source:"@site/docs/02_Management/02_03_Deployment/02_03_05_Destructive_Change.md",sourceDirName:"02_Management/02_03_Deployment",slug:"/Management/02_03_Deployment/02_03_05_Destructive_Change",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_Management/02_03_Deployment/02_03_05_Destructive_Change.md",tags:[{label:"Managment",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/managment"},{label:"Deployment",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/deployment"},{label:"Destructive Change",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/destructive-change"}],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Destructive Change",tags:["Managment","Deployment","Destructive Change"]},sidebar:"tutorialSidebar",previous:{title:"Run Tests for Deployment",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment"},next:{title:"Quick Deploy",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_06_Quick_Deployment"}},d={},c=[{value:"Technical Implementation of Destructive Changes",id:"technical-implementation-of-destructive-changes",level:2},{value:"Executing Destructive Changes Before Deployment",id:"executing-destructive-changes-before-deployment",level:2},{value:"Advantages",id:"advantages",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Executing Destructive Changes After Deployment",id:"executing-destructive-changes-after-deployment",level:2},{value:"Advantages",id:"advantages-1",level:3},{value:"Disadvantages",id:"disadvantages-1",level:3},{value:"Destructive Changes as a Separate Process",id:"destructive-changes-as-a-separate-process",level:2},{value:"Advantages",id:"advantages-2",level:3},{value:"Disadvantages",id:"disadvantages-2",level:3},{value:"When It\u2019s Justified",id:"when-its-justified",level:3}];function l(e){const n={br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Destructive Changes"})," refer to the process of removing outdated metadata (such as fields, objects, classes, pages, and other components) that are no longer needed in the target environment. This is important for maintaining system cleanliness and improving performance, as it helps eliminate unused or outdated components."]}),"\n",(0,s.jsxs)(n.p,{children:["Destructive changes are typically executed through a specific file, ",(0,s.jsx)(n.code,{children:"destructiveChanges.xml"}),", which lists the components to be removed. This file is included in the deployment, and upon execution, the specified components are deleted from the target environment."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Destructive Changes"})," can be executed in different scenarios: before the main deployment, after the main deployment, or as a separate process. The approach depends on deployment goals and the system\u2019s change management strategy."]}),"\n",(0,s.jsx)(n.h2,{id:"technical-implementation-of-destructive-changes",children:"Technical Implementation of Destructive Changes"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"destructive-changes"})," command is used as an addition to the deployment command, allowing for metadata deletion. There are two options for this:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"--post-destructive-changes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"--pre-destructive-changes"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["After the flag, you need to specify the path to a ",(0,s.jsx)(n.code,{children:"package.xml"})," file (the filename can be customized, such as ",(0,s.jsx)(n.code,{children:"destructiveChangesPre.xml"}),") containing the metadata to be deleted."]}),"\n",(0,s.jsxs)(n.p,{children:["For example:",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.code,{children:"$ sf project deploy start --manifest path/to/package.xml --target-org my-org --post-destructive-changes path/to/destructiveChangesPost.xml"}),(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"}),(0,s.jsx)(n.br,{}),"\n","In this command, ",(0,s.jsx)(n.code,{children:"--manifest path/to/package.xml"})," can be empty, containing no metadata. In such cases, only the destructive changes will be executed."]}),"\n",(0,s.jsx)(n.h2,{id:"executing-destructive-changes-before-deployment",children:"Executing Destructive Changes Before Deployment"}),"\n",(0,s.jsx)(n.p,{children:"Running destructive changes before the main deployment removes unnecessary components from the target environment before updating the remaining ones. This method is useful when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The team wants to clean the environment of outdated or conflicting components before introducing new functionality."}),"\n",(0,s.jsx)(n.li,{children:"Space is needed for components that will be updated or replaced in the current deployment."}),"\n",(0,s.jsx)(n.li,{children:"When there are dependencies on new components that need to be overridden or updated."}),"\n",(0,s.jsx)(n.li,{children:"In deployments with significant changes to the metadata structure, where it\u2019s important to clear the environment of conflicting components in advance."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced Deployment Conflicts"}),": Removing unnecessary or conflicting components before deployment helps avoid conflicts associated with creating new versions of components."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Environment Cleanliness"}),": Clearing outdated components before deployment keeps the environment up-to-date, simplifying metadata management."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Risk of Removing Necessary Components"}),": There must be certainty that the components marked for deletion are no longer needed. Otherwise, essential metadata may be inadvertently removed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Deployment Preparation"}),": Thorough testing is required to confirm that no dependencies exist that could cause failures."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"executing-destructive-changes-after-deployment",children:"Executing Destructive Changes After Deployment"}),"\n",(0,s.jsx)(n.p,{children:"This approach involves removing components after the main deployment. It is beneficial when it\u2019s essential to implement updates first and then remove unnecessary components to ensure the new code and metadata work correctly.\nThis method is useful when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"After successful implementation of the main functionality, to ensure that component removal does not lead to system failures."}),"\n",(0,s.jsx)(n.li,{children:"In deployments requiring a smooth transition with the option to restore deleted components in case of unforeseen issues."}),"\n",(0,s.jsx)(n.li,{children:"When additional testing of the main deployment is needed before removing redundant components."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advantages-1",children:"Advantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced Risk of Critical Changes"}),": The main deployment first updates the system, and only then are unnecessary components removed, reducing the risk if deleted components are still needed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Smoother Transition"}),": Executing destructive changes after deployment provides a smoother transition, as priority is given to adding new functionality rather than removing outdated parts."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"disadvantages-1",children:"Disadvantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Potential Conflicts with Updated Components"}),": If destructive changes were not planned in advance, conflicts could arise after implementing new functionality."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"destructive-changes-as-a-separate-process",children:"Destructive Changes as a Separate Process"}),"\n",(0,s.jsx)(n.p,{children:"In some cases, it makes sense to perform destructive changes as a separate process. This is justified, for example, when a large cleanup of outdated components is needed, separate from the main deployment."}),"\n",(0,s.jsx)(n.h3,{id:"advantages-2",children:"Advantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced Risk to Other Processes"}),": Destructive changes are carried out independently, reducing the risk to the current version."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibility"}),": The team has more freedom to plan and initiate destructive changes as needed, without linking them to main releases."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simplified Testing and Control"}),": A separate process makes it easier to control component removal and allows for easy restoration of deleted metadata if necessary."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"disadvantages-2",children:"Disadvantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Additional Support and Control Required"}),": Extra resources and time are needed to carry out destructive changes, which may prolong the environment maintenance process."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Need to Track Dependencies"}),": Destructive changes performed separately may impact other components if strict dependency control is not ensured."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-its-justified",children:"When It\u2019s Justified"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For routine cleanup of outdated or unnecessary components not tied to main releases."}),"\n",(0,s.jsx)(n.li,{children:"When there is a significant volume of destructive changes that are challenging to integrate into the main deployment."}),"\n",(0,s.jsx)(n.li,{children:"When changes are unrelated to new functionalities and are necessary to maintain order in the environment."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>o});var s=t(7294);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);