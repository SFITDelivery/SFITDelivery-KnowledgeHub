"use strict";(self.webpackChunksfit_delivery_knowledge_hub=self.webpackChunksfit_delivery_knowledge_hub||[]).push([[9846],{4705:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var s=n(5893),i=n(1151);const a={sidebar_position:4,title:"Run Tests for Deployment",tags:["Managment","Deployment","Tests"]},r=void 0,l={id:"Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment",title:"Run Tests for Deployment",description:"Effective testing is crucial to ensuring the quality of deployed changes. Choosing the right approach for test execution helps optimize time and resource costs while minimizing risks associated with potential errors. This article examines two main approaches to test execution during deployment: running all tests (RunLocalTests) and running specific tests (RunSpecifiedTests). Each approach has its advantages and disadvantages, and the choice depends on the project\u2019s current goals and CI/CD strategy.",source:"@site/docs/02_Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment.md",sourceDirName:"02_Management/02_03_Deployment",slug:"/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment.md",tags:[{label:"Managment",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/managment"},{label:"Deployment",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/deployment"},{label:"Tests",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/tests"}],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Run Tests for Deployment",tags:["Managment","Deployment","Tests"]},sidebar:"tutorialSidebar",previous:{title:"Deployment Options for Metadata",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment"},next:{title:"Destructive Change",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change"}},o={},c=[{value:"Running All Tests \u2014 RunLocalTests",id:"running-all-tests--runlocaltests",level:2},{value:"Technical Implementation of Tests",id:"technical-implementation-of-tests",level:3},{value:"Advantages",id:"advantages",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Running all tests with the <strong>RunLocalTests</strong> parameter is appropriate in the following scenarios:",id:"running-all-tests-with-the-runlocaltests-parameter-is-appropriate-in-the-following-scenarios",level:3},{value:"Running Specific Tests \u2014 RunSpecifiedTests",id:"running-specific-tests--runspecifiedtests",level:2},{value:"Technical Implementation of RunSpecifiedTests",id:"technical-implementation-of-runspecifiedtests",level:3},{value:"Advantages",id:"advantages-1",level:3},{value:"Disadvantages",id:"disadvantages-1",level:3},{value:"Running tests with the <strong>RunSpecifiedTests</strong> parameter is appropriate in the following scenarios:",id:"running-tests-with-the-runspecifiedtests-parameter-is-appropriate-in-the-following-scenarios",level:3}];function d(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Effective testing is crucial to ensuring the quality of deployed changes. Choosing the right approach for test execution helps optimize time and resource costs while minimizing risks associated with potential errors. This article examines two main approaches to test execution during deployment: running all tests (RunLocalTests) and running specific tests (RunSpecifiedTests). Each approach has its advantages and disadvantages, and the choice depends on the project\u2019s current goals and CI/CD strategy."}),"\n",(0,s.jsx)(t.h2,{id:"running-all-tests--runlocaltests",children:"Running All Tests \u2014 RunLocalTests"}),"\n",(0,s.jsxs)(t.p,{children:["Using the ",(0,s.jsx)(t.strong,{children:"RunLocalTests"})," parameter during deployment initiates all local tests written in the project (excluding tests in managed packages or those dependent on external packages). If tests are deployed within a package, the version from the current deployment is used. This approach ensures a high degree of code quality and system stability verification before introducing changes to the target environment."]}),"\n",(0,s.jsx)(t.h3,{id:"technical-implementation-of-tests",children:"Technical Implementation of Tests"}),"\n",(0,s.jsxs)(t.p,{children:["The technical implementation of tests is independent of the chosen deployment type. Whether you select deployment by directory, specific files, or ",(0,s.jsx)(t.code,{children:"package.xml"}),", the approach remains the same."]}),"\n",(0,s.jsxs)(t.p,{children:["To run all local tests (including those in the deployment), you need to specify the following option: ",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(t.code,{children:"--test-level RunLocalTests"})]}),"\n",(0,s.jsxs)(t.p,{children:["For example: ",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(t.code,{children:"$ sf project deploy start --manifest path/to/package.xml --target-org my-org --test-level RunLocalTests"})]}),"\n",(0,s.jsx)(t.h3,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Maximum Confidence in Code Quality"}),": Running all local tests ensures that even non-obvious errors unrelated to the current changes are detected, helping to prevent issues that might otherwise go unnoticed with selective testing."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"System Integrity"}),": Running all tests before deployment confirms that new changes do not break existing functionality, supporting system integrity across all modules."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Standardization of the Testing Process"}),": Regularly running all tests maintains high development standards and standardizes code review processes, which is particularly beneficial for large teams with varied responsibilities."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Detection of Hidden Dependencies"}),": Running all tests highlights dependencies between modules and objects that might be affected by changes, reducing the risk of unexpected failures in the production environment."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Increased Deployment Time"}),": Running all tests can take considerable time, especially on large projects with many classes, lengthening the delivery process, which is critical when frequent deployments or urgent releases, such as HotFixes, are required."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Increased CI/CD Infrastructure Load"}),": Running all tests requires additional computational resources, increasing the load on the CI/CD infrastructure and potentially reducing performance for other tasks."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Redundant Testing for Minor Changes"}),": For small or localized changes, running all tests may be excessive, as many tests are unrelated to the changes, making the deployment process less efficient."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Risk of False Positives"}),": With a large volume of tests, the likelihood of false positives increases, requiring additional time for checking and analyzing results."]}),"\n"]}),"\n",(0,s.jsxs)(t.h3,{id:"running-all-tests-with-the-runlocaltests-parameter-is-appropriate-in-the-following-scenarios",children:["Running all tests with the ",(0,s.jsx)(t.strong,{children:"RunLocalTests"})," parameter is appropriate in the following scenarios:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Significant Changes or Deployment to Production"}),": For critical releases and deployments to production, running all tests helps ensure stability and code quality."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Regression Before Major Releases"}),": Full testing is beneficial before large releases to ensure that all aspects of the system work correctly after substantial changes."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Stable CI/CD Infrastructure"}),": If the team has a well-organized CI/CD infrastructure with sufficient resources, regularly running all tests helps maintain a high level of quality."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Projects with High Component Dependency"}),": In large projects with closely interconnected components and complex dependencies, running all tests helps identify potential issues early on."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"running-specific-tests--runspecifiedtests",children:"Running Specific Tests \u2014 RunSpecifiedTests"}),"\n",(0,s.jsxs)(t.p,{children:["Using the ",(0,s.jsx)(t.strong,{children:"RunSpecifiedTests"})," parameter during deployment executes only specified tests, enabling the team to run only those necessary to verify specific changes. This method is particularly useful when rapid changes need to be deployed without involving the entire test suite and is preferred for optimizing CI/CD processes in projects with frequent, small updates."]}),"\n",(0,s.jsx)(t.p,{children:"As an option for storing the test database to run specified tests, it\u2019s possible to use a test coverage matrix."}),"\n",(0,s.jsx)(t.h3,{id:"technical-implementation-of-runspecifiedtests",children:"Technical Implementation of RunSpecifiedTests"}),"\n",(0,s.jsxs)(t.p,{children:["Similar to ",(0,s.jsx)(t.code,{children:"RunLocalTests"}),", the technical implementation of ",(0,s.jsx)(t.code,{children:"RunSpecifiedTests"})," does not depend on the selected deployment type. Whether you choose deployment by directory, specific files, or ",(0,s.jsx)(t.code,{children:"package.xml"}),", the approach remains the same."]}),"\n",(0,s.jsxs)(t.p,{children:["To run specified tests (including those in the deployment), you need to set the option: ",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(t.code,{children:"--test-level RunSpecifiedTests"})," ",(0,s.jsx)("br",{}),"\nand specify the tests using the ",(0,s.jsx)(t.code,{children:"--tests"})," flag."]}),"\n",(0,s.jsxs)(t.p,{children:["For example: ",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(t.code,{children:"$ sf project deploy start --manifest path/to/package.xml --target-org my-org --test-level RunSpecifiedTests --tests MyTest1 --tests MyTest2 --tests MyTest3"})," ",(0,s.jsx)("br",{}),"\nNote: Only the test names should be specified\u2014omit the ",(0,s.jsx)(t.code,{children:".cls"})," extension."]}),"\n",(0,s.jsx)(t.h3,{id:"advantages-1",children:"Advantages"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Time Savings and Faster Deployment"}),": Running only necessary tests significantly reduces deployment time, especially in large projects with numerous tests where a full run could be too lengthy."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Reduced CI/CD Infrastructure Load"}),": The ",(0,s.jsx)(t.strong,{children:"RunSpecifiedTests"})," parameter reduces the load on CI/CD infrastructure as it requires fewer resources than running all tests."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Testing Flexibility"}),": The ability to select specific tests gives the team flexible control, enabling them to run only critical tests or those directly related to changes, which helps detect potential issues faster."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Optimization for Urgent Fixes and Frequent Releases"}),": Deploying with only the necessary tests suits situations where quick fixes (such as HotFixes) are needed, avoiding the delay of running all tests and thus minimizing downtime and speeding up release."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Quality Control"}),": This method fits well within quality control systems and automated CI/CD processes. For example, when a class is changed in a pull request to the integration branch, only related tests can be automatically triggered, allowing issues to be detected early."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"disadvantages-1",children:"Disadvantages"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Risk of Missing Dependent Tests"}),": If modified components rely on other parts of the system, running only specific tests might not cover all possible scenarios, increasing the chance of errors that a full test run could reveal."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Need to Maintain Test Lists"}),": Maintaining up-to-date test lists is necessary, particularly if the project is actively evolving. This may increase the team\u2019s workload, as they must carefully select tests for each deployment and maintain systems of control, like a test coverage matrix."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Risk of a False Sense of Security"}),": Running only selected tests may lead the team to underestimate the potential impact of changes on other parts of the system, creating a risk of unnoticed errors in other modules."]}),"\n"]}),"\n",(0,s.jsxs)(t.h3,{id:"running-tests-with-the-runspecifiedtests-parameter-is-appropriate-in-the-following-scenarios",children:["Running tests with the ",(0,s.jsx)(t.strong,{children:"RunSpecifiedTests"})," parameter is appropriate in the following scenarios:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Frequent and Small Changes"}),": If the team makes frequent but minor updates, running only necessary tests helps accelerate deployment and reduce the load on CI/CD infrastructure."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"HotFixes and Urgent Updates"}),": In cases where a quick release is needed to fix an error, running only critical tests enables fast deployment, minimizing the time needed to deliver fixes."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Testing of Independent Components"}),": When changes are isolated to specific functionality, running only relevant tests allows focus on the needed areas without requiring all tests to be executed."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>r});var s=n(7294);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);