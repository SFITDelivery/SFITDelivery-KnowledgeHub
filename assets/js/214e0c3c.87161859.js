"use strict";(self.webpackChunksfit_delivery_knowledge_hub=self.webpackChunksfit_delivery_knowledge_hub||[]).push([[3761],{5681:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=t(5893),a=t(1151);const r={sidebar_position:9,title:"Test Coverage Matrix",tags:["Managment","Deployment","Tests"]},i=void 0,o={id:"Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix",title:"Test Coverage Matrix",description:"The Test Coverage Matrix is a tool that tracks the relationship between test classes and the classes they cover, along with additional information such as coverage percentage, the date of the last test run, and comments. It is a vital tool for managing code quality, providing simplified access to test coverage data, and enabling change tracking.",source:"@site/docs/02_Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix.md",sourceDirName:"02_Management/02_03_Deployment",slug:"/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix.md",tags:[{label:"Managment",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/managment"},{label:"Deployment",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/deployment"},{label:"Tests",permalink:"/SFITDelivery-KnowledgeHub/docs/tags/tests"}],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"Test Coverage Matrix",tags:["Managment","Deployment","Tests"]},sidebar:"tutorialSidebar",previous:{title:"Unlocked Packages",permalink:"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages"},next:{title:"Metadata - Deployment Features",permalink:"/SFITDelivery-KnowledgeHub/docs/category/metadata---deployment-features"}},l={},c=[{value:"Why Do You Need a Test Coverage Matrix?",id:"why-do-you-need-a-test-coverage-matrix",level:2},{value:"Key Requirements for the Matrix",id:"key-requirements-for-the-matrix",level:2},{value:"Example of a Test Coverage Matrix",id:"example-of-a-test-coverage-matrix",level:2},{value:"XML Example",id:"xml-example",level:3},{value:"JSON Example",id:"json-example",level:3},{value:"YAML Example",id:"yaml-example",level:3},{value:"How to Retrieve Data for the Matrix",id:"how-to-retrieve-data-for-the-matrix",level:2},{value:"1. Overall Coverage for Each Class or Trigger",id:"1-overall-coverage-for-each-class-or-trigger",level:3},{value:"2. Coverage by Test Method",id:"2-coverage-by-test-method",level:3},{value:"3. Validating Coverage via Tests",id:"3-validating-coverage-via-tests",level:3},{value:"Ideal Project Profile for Using a Test Coverage Matrix",id:"ideal-project-profile-for-using-a-test-coverage-matrix",level:2}];function d(e){const s={br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.strong,{children:"Test Coverage Matrix"})," is a tool that tracks the relationship between test classes and the classes they cover, along with additional information such as coverage percentage, the date of the last test run, and comments. It is a vital tool for managing code quality, providing simplified access to test coverage data, and enabling change tracking."]}),"\n",(0,n.jsx)(s.p,{children:"The matrix is structured data that can be represented in various formats, such as XML, JSON, or YAML."}),"\n",(0,n.jsx)(s.h2,{id:"why-do-you-need-a-test-coverage-matrix",children:"Why Do You Need a Test Coverage Matrix?"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Simplifying Test Coverage Analysis"}),(0,n.jsx)(s.br,{}),"\n","The matrix offers an easy way to identify which tests cover specific classes and evaluate their coverage levels. This is particularly important for large projects with extensive codebases, where manual analysis becomes overly time-consuming."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Managing Dependencies and Testing Priorities"}),(0,n.jsx)(s.br,{}),"\n","The matrix helps efficiently manage relationships between tests and classes, allowing you to run only the necessary tests. This reduces testing time and is especially useful in scenarios requiring quick responses, such as deploying ",(0,n.jsx)(s.strong,{children:"hotfixes"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Historical Tracking and Diagnostics"}),(0,n.jsx)(s.br,{}),"\n","Storing information about the date of the last test run and coverage levels helps track the relevance of tests, identify outdated or irrelevant tests, and detect changes that have impacted coverage."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Improving Coverage Data Quality"}),(0,n.jsx)(s.br,{}),"\n","The matrix compensates for the shortcomings of Salesforce\u2019s built-in test coverage data by providing an independent and reliable source. This ensures accurate analysis and verification of data."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Automating Code Quality Control"}),(0,n.jsx)(s.br,{}),"\n","The matrix supports automation of quality control processes, ensuring transparency in test coverage. This helps maintain development standards and speeds up the resolution of identified issues."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Integration with DevOps and CI/CD Processes"}),(0,n.jsx)(s.br,{}),"\n","The matrix simplifies the integration of testing into CI/CD pipelines, optimizing the deployment and verification of changes. This makes processes more consistent and reliable."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Accelerating Code Reviews and Audits"}),(0,n.jsx)(s.br,{}),"\n","The matrix facilitates the analysis of coverage for changes, helping reviewers and testers quickly verify code quality and identify gaps."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Fostering a Culture of Test Improvement"}),(0,n.jsx)(s.br,{}),"\n","A transparent data structure in the matrix motivates teams to track testing progress. Increasing coverage percentages and clearly understanding the current state promote a culture of quality and collaboration."]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"key-requirements-for-the-matrix",children:"Key Requirements for the Matrix"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Developer Usability"}),(0,n.jsx)(s.br,{}),"\n","The matrix should be intuitive and accessible to all development team members. It should provide information in an easy-to-use format (e.g., JSON, XML, or YAML) and integrate seamlessly into the team's workflows. The interface or file structure should minimize time spent working with the data."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Automation-Friendly"}),(0,n.jsx)(s.br,{}),"\n","The matrix should easily integrate with automation tools like CI/CD pipelines or quality control systems. Its data format should be standardized and suitable for programmatic processing, enabling scenarios like automated report generation and coverage checks during deployment."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Support for Multiple Test Classes Per Class"}),(0,n.jsx)(s.br,{}),"\n","In complex projects, a single class may be covered by multiple tests. The matrix should support specifying multiple test classes for one validated class to ensure transparency and meet project coverage requirements."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Ability to Add Comments"}),(0,n.jsx)(s.br,{}),"\n","The matrix should allow for adding comments to classes, tests, or their relationships. These comments could include critical information for developers, such as the reason for insufficient coverage or specific testing details. Additionally, some comments can be used in automation logic, such as skipping specific classes in tests or providing processing instructions."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Data Relevance"}),(0,n.jsx)(s.br,{}),"\n","The matrix should include information about the last update of coverage for each class. This helps teams analyze the relevance of data and take timely actions to update it, avoiding the use of outdated or irrelevant information."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Principle of Necessity and Sufficiency"}),(0,n.jsx)(s.br,{}),"\n","The matrix should avoid redundancy by storing only necessary and sufficient information. This means including only those tests and classes that have actual relationships and are important for coverage analysis. Excessive detail or data duplication can complicate the use of the matrix and automation processes."]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"example-of-a-test-coverage-matrix",children:"Example of a Test Coverage Matrix"}),"\n",(0,n.jsx)(s.h3,{id:"xml-example",children:"XML Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<classes>\n\t<class>\n\t\t<testname>MyClassTest.cls</testname>\n\t\t<coverage>100.0%</coverage>\n\t\t<date>2023_12_31</date>\n\t\t<classname>MyClass.cls</classname>\n\t\t<description>Specific dependencies</description>\n\t</class>\n\t<class>\n\t\t<testname>MyClass2Test.cls</testname>\n\t\t<coverage>76.62%</coverage>\n\t\t<date>2023_12_31</date>\n\t\t<classname>MyClass2.cls</classname>\n\t\t<description>Note on the class</description>\n\t</class>\n\t<class>\n\t\t<testname>MyClass1Test.cls</testname>\n\t\t<testname>MyClass3Test.cls</testname>\n\t\t<coverage>91.37%</coverage>\n\t\t<date>2023_12_31</date>\n\t\t<classname>MyClass3.cls</classname>\n\t\t<description>Note on coverage</description>\n\t</class>\n</classes>\n'})}),"\n",(0,n.jsx)(s.h3,{id:"json-example",children:"JSON Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-json",children:'[\n    {\n        "testname": "MyClassTest.cls",\n        "coverage": "100.0%",\n        "date": "2023_12_31",\n        "classname": "MyClass.cls",\n        "description": "Specific dependencies"\n    },\n    {\n        "testname": "MyClass2Test.cls",\n        "coverage": "76.62%",\n        "date": "2023_12_31",\n        "classname": "MyClass2.cls",\n        "description": "Note on the class"\n    },\n    {\n        "testname": [\n            "MyClass1Test.cls",\n            "MyClass3Test.cls"\n        ],\n        "coverage": "91.37%",\n        "date": "2023_12_31",\n        "classname": "MyClass3.cls",\n        "description": "Note on coverage"\n    }\n]\n\n'})}),"\n",(0,n.jsx)(s.h3,{id:"yaml-example",children:"YAML Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-YAML",children:'- testname: MyClassTest.cls\n  coverage: "100.0%"\n  date: 2023_12_31\n  classname: MyClass.cls\n  description: Specific dependencies\n- testname: MyClass2Test.cls\n  coverage: "76.62%"\n  date: 2023_12_31\n  classname: MyClass2.cls\n  description: Note on the class\n- testname:\n    - MyClass1Test.cls\n    - MyClass3Test.cls\n  coverage: "91.37%"\n  date: 2023_12_31\n  classname: MyClass3.cls\n  description: Note on coverage\n'})}),"\n",(0,n.jsx)(s.h2,{id:"how-to-retrieve-data-for-the-matrix",children:"How to Retrieve Data for the Matrix"}),"\n",(0,n.jsxs)(s.p,{children:["To build the test coverage matrix or analyze code coverage in Salesforce, ",(0,n.jsx)(s.strong,{children:"SOQL queries"})," can be used via the ",(0,n.jsx)(s.strong,{children:"Tooling API"}),". Below are methods to extract coverage data."]}),"\n",(0,n.jsx)(s.h3,{id:"1-overall-coverage-for-each-class-or-trigger",children:"1. Overall Coverage for Each Class or Trigger"}),"\n",(0,n.jsxs)(s.p,{children:["Use this query to retrieve aggregated code coverage for each class or trigger: ",(0,n.jsx)("br",{}),"\n",(0,n.jsx)(s.code,{children:"SELECT ApexClassOrTrigger.Name, NumLinesUncovered, NumLinesCovered FROM ApexCodeCoverageAggregate"})," ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Fields in the Result:"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"ApexClassOrTrigger.Name"}),": The name of the class or trigger."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"NumLinesUncovered"}),": The number of uncovered lines."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"NumLinesCovered"}),": The number of covered lines."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"This query is suitable for high-level analysis of code coverage in a project."}),"\n",(0,n.jsx)(s.h3,{id:"2-coverage-by-test-method",children:"2. Coverage by Test Method"}),"\n",(0,n.jsxs)(s.p,{children:["For a detailed analysis, including information about test methods, use the following query: ",(0,n.jsx)("br",{}),"\n",(0,n.jsx)(s.code,{children:"SELECT ApexTestClass.Name, TestMethodName, ApexClassOrTrigger.Name, NumLinesUncovered, NumLinesCovered FROM ApexCodeCoverage"}),(0,n.jsx)("br",{}),"\n",(0,n.jsx)(s.strong,{children:"Fields in the Result:"})]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"ApexTestClass.Name"}),": Name of the test class."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"TestMethodName"}),": Name of the test method."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"ApexClassOrTrigger.Name"}),": Name of the class or trigger being tested."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"NumLinesUncovered"}),": Number of uncovered lines."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"NumLinesCovered"}),": Number of covered lines."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"This query is ideal for building a detailed matrix that shows relationships between test methods and classes."}),"\n",(0,n.jsx)(s.h3,{id:"3-validating-coverage-via-tests",children:"3. Validating Coverage via Tests"}),"\n",(0,n.jsxs)(s.p,{children:["To validate a class with specific tests, use the following command: ",(0,n.jsx)("br",{}),"\n",(0,n.jsx)(s.code,{children:"sf project deploy validate --source-dir <path to class> --target-org <target env> --test-level RunSpecifiedTests --tests <testname> --wait 120 --json"})," ",(0,n.jsx)("br",{}),"\nThe command returns validation results in JSON format, including the number of lines covered and uncovered."]}),"\n",(0,n.jsxs)(s.p,{children:["Alternatively, to retrieve results later:",(0,n.jsx)("br",{}),"\n",(0,n.jsx)(s.code,{children:" sf project deploy report --target-org <target env> --job-id <job ID> --json"})," ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.p,{children:"This method provides accurate coverage data but requires automation for efficiency."}),"\n",(0,n.jsx)(s.h2,{id:"ideal-project-profile-for-using-a-test-coverage-matrix",children:"Ideal Project Profile for Using a Test Coverage Matrix"}),"\n",(0,n.jsx)(s.p,{children:"A test coverage matrix is most beneficial in projects with high code quality standards, complex structures, and frequent changes. Characteristics of such projects include:"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Large Projects with Extensive Codebases"}),(0,n.jsx)(s.br,{}),"\n","Necessary for projects with dozens or hundreds of classes, triggers, and tests where manual coverage analysis is impractical."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Frequent Changes and Rapid Development Cycles"}),(0,n.jsx)(s.br,{}),"\n","Essential in agile or DevOps environments where changes are made daily or weekly."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"CI/CD and DevOps Integration"}),(0,n.jsx)(s.br,{}),"\n","The matrix fits seamlessly into automated CI/CD pipelines, accelerating deployment and minimizing risks from insufficient coverage."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"High Code Quality Standards"}),(0,n.jsx)(s.br,{}),"\n","Critical for projects with strict coverage requirements (e.g., 85-90%)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Complex Dependency Structures"}),(0,n.jsx)(s.br,{}),"\n","Necessary for managing relationships between interdependent components."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Large Development Teams"}),(0,n.jsx)(s.br,{}),"\n","Supports coordination in multi-branch development environments."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Salesforce DX and Unlocked Packages"}),(0,n.jsx)(s.br,{}),"\n","Aids in managing coverage at the package level for modular projects."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Multiple Production Environments"}),(0,n.jsx)(s.br,{}),"\n","Maintains consistency across regions or business units."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Transparency and Auditing Requirements"}),(0,n.jsx)(s.br,{}),"\n","Provides a clear source of coverage data for compliance and reviews."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Projects involving vendors"}),(0,n.jsx)(s.br,{}),"\n","Using a matrix simplifies tracking the quality of development and adherence to standards on the project."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1151:(e,s,t)=>{t.d(s,{Z:()=>o,a:()=>i});var n=t(7294);const a={},r=n.createContext(a);function i(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);