{"searchDocs":[{"title":"The release management section has been updated.","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/blog/release_management_section_added","content":"Basic articles have been added to the release management section. The articles contain information on methodology and practical advice on release management, with a separate note dedicated to HotFix. Anti-patterns can help conduct a quick, superficial review of the project's release management processes, allowing for the identification of common mistakes and shortcomings.","keywords":"","version":null},{"title":"Adding articles and updating the structure.","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/blog/git-and-roles-and-structure","content":"The portal structure has been modified for easier navigation. Articles on Roles and Git Management, including descriptions of strategies and comparisons, have been added. Articles on other topics are currently being created.","keywords":"","version":null},{"title":"The deployment management section has been updated.","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/blog/deployment_management_section_added","content":"Basic articles have been added to the deployment management section. In this section, you will find materials that will help optimize deployment processes, and improve system stability. The section includes articles on the following key topics: Basics of Deployment Management: Understanding the differences between release and deployment stages to minimize risks and improve planning.Process Automation: Fundamental principles and approaches to automation for increased reliability and efficiency.Metadata Deployment Approaches: Choosing between full and partial deployment to optimize resources and enhance control.Testing During Deployment: Running tests to ensure high quality and system stability.Removing Outdated Components: Recommendations for implementing destructive changes to maintain order and relevance in the system.Quick Deploy: Leveraging accelerated deployment for critical changes.Version Management: Utilizing modular approaches and Salesforce packages to simplify updates and improve control.Quality Control: Using test coverage matrices for transparent analysis and quality improvement. This section will become a valuable tool for teams aiming to optimize development and deployment processes in Salesforce. If you'd like to contribute, join the project!","keywords":"","version":null},{"title":"Welcome","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/blog/welcome","content":"DevOps and Delivery practices are underdeveloped in Salesforce projects. Small projects often do not integrate these roles with the existing ones on the project, such as developers. Large projects turn to off-the-shelf products. All of this leads to suboptimal solutions, or pitfalls laid at the foundation of the project. This resource is created for sharing and accumulating experience and best DevOps and Delivery practices within Salesforce and cross-projects. Here, you will find documentation and technical solutions. Please feel free to propose your changes/solutions/edits - this is an open project. Let's make this world a better place!","keywords":"","version":null},{"title":"Automatization Index","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Automatization/","content":"Automatization Index","keywords":"","version":"Next"},{"title":"Mass Delete Unused Flow and Process Builder Versions in Salesforce","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Automatization/100_01_delete_flow","content":"","keywords":"","version":"Next"},{"title":"Apex script​","type":1,"pageTitle":"Mass Delete Unused Flow and Process Builder Versions in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Automatization/100_01_delete_flow#apex-script","content":" apex script  String soqlQuery = 'Select ID From Flow Where (Status = \\'Obsolete\\' OR Status = \\'Draft\\') AND VersionNumber &gt; 1'; String orgUrl = URL.getSalesforceBaseUrl().toExternalForm(); HttpRequest flowIdRequest = new HttpRequest(); flowIdRequest.setMethod('GET'); flowIdRequest.setHeader('Authorization', 'Bearer ' + UserInfo.getSessionId()); flowIdRequest.setEndpoint(orgUrl+'/services/data/v50.0/tooling/query?q=SELECT+id,status+FROM+Flow+Where+(+Status+=+\\'Obsolete\\'+OR+Status+=+\\'Draft\\'+)+AND+VersionNumber+&gt;+1'); //flowIdRequest.setTimeout(120000); Http http = new Http(); HttpResponse httpResponse = http.send(flowIdRequest); List&lt;Object&gt; records = (List&lt;Object&gt;)((Map&lt;String, Object&gt;)JSON.deserializeUntyped(httpResponse.getBody())).get('records'); //get id String[] ids = new List&lt;String&gt;(); for (Object variable : records) { String str = variable.ToString(); String res = str.substringBefore(', Status'); res = res.substringAfter('Id='); ids.add(res); } //delete HttpRequest flowIdRequestDelete = new HttpRequest(); for (String idFlow : ids) { flowIdRequestDelete.setMethod('DELETE'); flowIdRequestDelete.setHeader('Authorization', 'Bearer ' + UserInfo.getSessionId()); flowIdRequestDelete.setEndpoint(orgUrl +'/services/data/v50.0/tooling/sobjects/Flow/'+idFlow); Http http = new Http(); HttpResponse httpResponseDelete = http.send(flowIdRequestDelete); }   ","version":"Next","tagName":"h2"},{"title":"Bash Script (Using a File):​","type":1,"pageTitle":"Mass Delete Unused Flow and Process Builder Versions in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Automatization/100_01_delete_flow#bash-script-using-a-file","content":" apex script  #!/bin/bash org=$1 # sandbox alias verMin=$2 # which version of the flow does the check start with verMaxDelta=$3 # how many versions of the flow will not be deleted counting from the active one # get the active version of the Active flow echo &quot;Request for Active flow versions&quot; mapfile resultActive &lt; &lt;(sfdx force:data:soql:query --query &quot;Select DefinitionId, VersionNumber From Flow Where Status = 'Active' AND VersionNumber &gt; $verMin&quot; --targetusername $org --usetoolingapi) &lt;&lt; RESULT these first two lines are excluded: DEFINITIONID VERSIONNUMBER ────────────────── ───────────── RESULT let &quot;a=${#resultActive[@]}-2&quot; # get the active version of Obsolete and Draft flow echo &quot;Request for Inactive flow versions&quot; mapfile resultInactive &lt; &lt;(sfdx force:data:soql:query --query &quot;Select ID, DefinitionId, VersionNumber From Flow Where (Status = 'Obsolete' OR Status = 'Draft') AND VersionNumber &gt; $verMin &quot; --targetusername $org --usetoolingapi) let &quot;b=${#resultInactive[@]}-2&quot; declare -a flowsArr echo &quot;I'm starting to process the lists&quot; for row in &quot;${resultInactive[@]:2:$b}&quot;;do IFS=' ' read -ra flowInactiv &lt;&lt;&lt; &quot;$row&quot; # we get a string divided into an array - Inactiv flow let &quot;verInactiveFlow = ${flowInactiv[2]}&quot; # the version of the inactive flow to check for value in &quot;${resultActive[@]:2:$a}&quot;;do IFS=' ' read -ra flowActiv &lt;&lt;&lt; &quot;$value&quot; # we get a string divided into an array - Activ flow let &quot;verActiveFlowAndDelta = ${flowActiv[1]} - $verMaxDelta&quot; # the version of the active flow with a delta for checking if [[ &quot;${flowActiv[0]}&quot; = &quot;${flowInactiv[1]}&quot; ]] then if (( $verInactiveFlow &lt; $verActiveFlowAndDelta )) then echo &quot;added for deletion ID &quot; ${flowInactiv[0]} flowsArr+=( ${flowInactiv[0]} ) #add &quot;Select ID&quot; form Inactive flow fi fi done done # Delete flows echo &quot;deletion starts &quot; echo ${#flowsArr[@]} &quot; flows are removed&quot; con=0 for flowDelete in &quot;${flowsArr[@]}&quot;;do con=$((con + 1)) sfdx force:data:record:delete --sobjecttype Flow --sobjectid $flowDelete --targetusername $org --usetoolingapi echo &quot;there are &quot; $((${#flowsArr[@]}-$con)) &quot; flows left&quot; done  ","version":"Next","tagName":"h2"},{"title":"HotFix","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_04_HotFix","content":"","keywords":"","version":"Next"},{"title":"What is a Hotfix?​","type":1,"pageTitle":"HotFix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_04_HotFix#what-is-a-hotfix","content":" A hotfix is an urgent fix for a critical error that has occurred in production and requires immediate resolution. Unlike planned releases, a hotfix is implemented without prior long-term planning and preparation, making the process riskier. However, with proper organization and adherence to a clear plan, a hotfix can be deployed quickly and safely.  ","version":"Next","tagName":"h3"},{"title":"Key Stages of Managing a Hotfix​","type":1,"pageTitle":"HotFix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_04_HotFix#key-stages-of-managing-a-hotfix","content":" 1. Assessing and Classifying the Problem​  The first step in the hotfix process is to assess and classify the problem. It is necessary to determine how critical the error is and whether it requires immediate intervention. A unified system for tracking, prioritizing, and managing issues should be established within the project.  Key questions for assessment:  Impact on business: How severely does the error affect key business processes? Could it lead to significant financial losses or operational disruptions?Number of affected users: How many users are affected by this issue? Is it an isolated incident or a widespread problem?Availability of a workaround: Is there a temporary solution that can mitigate the issue until a permanent fix is implemented?  2. Rapid Development and Testing of the Fix​  Once the problem is classified, the team must promptly start developing the fix. It is important to minimize the time spent on this stage while ensuring the quality of the solution.  Steps for development and testing:  Isolated development environment: The hotfix should be developed in an isolated environment to avoid impacting other changes or ongoing developments.Minimization of changes: The changes should be minimal to reduce the risk of introducing new errors.Testing: Despite the urgency, it is crucial to conduct all possible tests in a sandbox environment. Automated and regression testing helps identify potential issues early.Use of a production-like environment: The hotfix should be tested in an environment that closely resembles the production environment.  3. Deploying the Hotfix to Production​  When the fix is ready and has passed testing, the next step is deploying it to production. This process requires precise coordination and attention to details.  Steps for deployment:  Rollback strategy: Before deploying the hotfix, it is important to have a strategy in place for quickly rolling back the changes if unforeseen problems arise.Notifying stakeholders: All key participants should be informed about the upcoming deployment to ensure that stakeholders are prepared for potential system instability.Gradual deployment: Depending on the complexity of the fix, it may be beneficial to deploy it gradually or on a limited scale (e.g., using Canary Releases) to ensure stability.  4. Monitoring and Evaluating Results​  After the hotfix is deployed, it is important to closely monitor the system and evaluate the results of the fix.  Key actions:  System monitoring: Use monitoring tools to track system performance and key metrics. Any deviations from the norm should be analyzed immediately.Collecting user feedback: Promptly gather feedback from users to ensure that the issue is resolved and no new problems have arisen.Incident analysis: After the system stabilizes, conduct an analysis of the incident to identify the root cause and determine how to prevent similar situations in the future.  ","version":"Next","tagName":"h3"},{"title":"How to Minimize Risks When Implementing a Hotfix​","type":1,"pageTitle":"HotFix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_04_HotFix#how-to-minimize-risks-when-implementing-a-hotfix","content":" Hotfixes always carry certain risks, but proper organization of the process can significantly reduce them.  1. Preparing for Potential Problems​  Rollback plan: Develop a rollback strategy to quickly restore the system to its previous stable state if problems arise.Failure procedures: Developing and documenting procedures for handling failures during the hotfix deployment is an important part of the hotfix process.  2. Automating Processes​  Automated testing: Using automated tests helps reduce testing time and improve its quality.CI/CD processes: Integrating the hotfix into CI/CD processes allows for automated deployment and minimizes the likelihood of errors.Git strategy: It is important that the Git strategy accommodates the possibility of conducting hotfixes in the most efficient way that meets the project’s requirements. Hotfix Git strategy.  3. Regular Drills and Training​  Training deployments: Regularly conduct hotfix drills in a test environment to ensure the team is prepared to act quickly in a real situation.Documentation and training: Ensure that the entire team is familiar with the hotfix management processes and has access to the necessary documentation and tools. It is important to keep the documentation up to date.  ","version":"Next","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"HotFix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_04_HotFix#conclusion","content":" Managing hotfixes is a complex but crucial aspect of release management in Salesforce projects. Prompt and safe deployment of urgent fixes requires careful planning, quality testing, and diligent monitoring. By following the steps and recommendations outlined above, you can minimize risks, quickly resolve critical issues, and maintain the stability of your Salesforce system. A well-structured hotfix process and strategy aligned with the project’s conditions contribute to the overall resilience of the system in the long term. ","version":"Next","tagName":"h3"},{"title":"DevOps and Delivery Management Knowledge Hub for Salesforce","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"DevOps and Delivery Management Knowledge Hub for Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/intro#introduction","content":" Welcome to the DevOps and Delivery Management Knowledge Hub for Salesforce – an open-source repository dedicated to providing DevOps solutions, delivery management practices, and best practices specifically tailored for Salesforce environments. This knowledge base is a comprehensive resource for DevOps professionals, Delivery Managers, and anyone working with Salesforce, offering a rich compilation of code templates, best practices, and community-contributed insights.  ","version":"Next","tagName":"h2"},{"title":"About the Project​","type":1,"pageTitle":"DevOps and Delivery Management Knowledge Hub for Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/intro#about-the-project","content":" Our mission is to create a centralized, community-driven repository that empowers Salesforce DevOps professionals and Delivery Managers with practical, up-to-date, and versatile resources. The knowledge base includes, but is not limited to:  Code Templates: Ready-to-use scripts and code snippets that facilitate quick and efficient Salesforce development and deployment.Best Practices: Curated methodologies and strategies for optimizing Salesforce DevOps and delivery management processes.Community Contributions: Contributions from experts and practitioners in the field, enriching the repository with diverse perspectives and innovative solutions. ","version":"Next","tagName":"h2"},{"title":"Anti-patterns","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_99_Anti_patterns","content":"Anti-patterns Lack of Unified Release Planning: Teams plan and execute releases independently without a unified roadmap or coordination. Ignoring Risk Assessment: Release planning is done without proper risk assessment or preparation for potential issues. Inadequate Incident Response Preparation: The team lacks a well-defined process for handling incidents, especially critical ones that require urgent attention. Over-Reliance on Manual Processes: Key processes, including testing and deployment, rely heavily on manual steps rather than automation. Poor Dependency Management: Dependencies between different teams and components are not properly managed or communicated. Frequent and Uncontrolled Releases: Releasing updates too frequently without sufficient testing or oversight, often driven by the pressure to deliver features quickly. Insufficient Communication Between Teams: Development teams work in silos with minimal communication, leading to misalignment and duplicated efforts. Failure to Adapt to Project-Specific Needs: Applying a one-size-fits-all release management strategy without considering the specific needs of the project or team.","keywords":"","version":"Next"},{"title":"Trunk-Based Development (TBD)","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_02_TBD","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"Trunk-Based Development (TBD)","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_02_TBD#implementation-examples","content":" The strategy can use feature branches and release branches, but the key feature is a single main branch. The example shows implementation scenarios: 1 - without using additional branches 2 - with feature branches 3 - with feature branches and release branches  ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Trunk-Based Development (TBD)","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_02_TBD#advantages","content":" Rapid Issue Identification and Resolution: Frequent commits and configured automation allow for quick detection and resolution of issues, especially integration problems. Simplified Branch Management: The absence of long-lived branches can simplify the code management process, reducing the likelihood of conflicts and merge errors. Improved Code Quality: TBD is accompanied by the automation of CI/CD processes, including testing, which helps maintain a high standard of code quality since each change is automatically verified. Faster Feature Delivery: Frequent releases allow for faster delivery of new features to users, improving time to market and customer satisfaction. Constant Deployment Readiness: The main branch is always in a state ready for production deployment, which simplifies and speeds up the release process. Better Team Interaction: The requirement for frequent commits and merges encourages the team to engage in more active interaction and coordination, improving teamwork. Enhanced Transparency: All changes occur in one branch, making the development process more transparent and accessible to all team members.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Trunk-Based Development (TBD)","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_02_TBD#disadvantages","content":" Scalability Issues: In large teams with many developers, frequent commits to one branch can lead to numerous conflicts and merge complexities. Discipline and Process Requirements: Successful TBD implementation requires high team discipline, well-organized processes, and a culture of continuous integration, which is not always easy to achieve. High Automation Demands: A good CI/CD system for automatic testing and deployment requires significant resources and time for setup and maintenance. Risk of Reduced Code Quality: Fast and frequent integrations can lead to the inclusion of insufficiently tested or low-quality code if the review and testing processes are not strict enough. Potential Performance Issues: Frequent merges can increase the load on the version control system and CI/CD infrastructure, potentially slowing down the integration and deployment process. Limited Experimentation Opportunities: The absence of long-lived branches can limit opportunities for long-term experiments and major changes that require more time for development and testing. Complex Testing: Feature flags are used to ensure that unfinished code does not interfere with the deployment of the main branch, which adds additional testing workload for different system configurations.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Trunk-Based Development (TBD)","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_02_TBD#features","content":" Feature FlagsThis development technique allows enabling or disabling features in an application without deploying new code. This is achieved by using conditional statements that check the flag's state and enable or disable the corresponding functionality.  ","version":"Next","tagName":"h3"},{"title":"Ideal Project Profile​","type":1,"pageTitle":"Trunk-Based Development (TBD)","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_02_TBD#ideal-project-profile","content":" Small to Medium Development Team: With a small number of developers, it is easier to coordinate frequent commits and integrations, reducing the risk of conflicts and simplifying branch management. High Level of Automation: A reliable and well-configured continuous integration and deployment (CI/CD) system that automatically performs tests, checks, and deployments is critical for the success of TBD. Culture of Code Quality: The team should adhere to high standards of code quality, regularly conduct code reviews, and ensure thorough testing before committing to the main branch. Effective Interaction and Communication: The team should have well-established communication and interaction processes to quickly address issues and coordinate their actions. Short-Term Tasks: Projects should be broken down into small, manageable tasks that can be completed within a few days or even hours to support frequent commits and integrations. Flexibility and Adaptability: The development process should be flexible and able to quickly adapt to changing requirements and conditions, helping to respond promptly to feedback and make necessary adjustments. Version Control and Monitoring Tools: Use of modern version control tools such as Git, as well as monitoring and performance analysis tools for timely issue detection and resolution. Management Support: Leadership should support the implementation of TBD by providing the necessary resources and creating conditions for the team's effective work. ","version":"Next","tagName":"h3"},{"title":"Large-scale Projects","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_05_Large-scale_Projects","content":"","keywords":"","version":"Next"},{"title":"Features of Large-Scale Projects​","type":1,"pageTitle":"Large-scale Projects","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_05_Large-scale_Projects#features-of-large-scale-projects","content":" Large-scale projects differ from smaller ones in several key parameters:  Multiple teams: Such projects involve multiple teams, each of which may work on its own part of the system or functionality.Diverse line management: In addition to teams working on different parts of the system, teams may report to different structures.Multiple dependencies: Changes made by one team may depend on the work of other teams, complicating the integration and testing process.Different locations and time zones: Often, teams are located in different geographical regions, creating additional coordination challenges.Complex business processes: Large-scale projects often implement complex business processes that require thorough verification and coordination of changes.  ","version":"Next","tagName":"h3"},{"title":"Release Management Strategies in Large-Scale Projects​","type":1,"pageTitle":"Large-scale Projects","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_05_Large-scale_Projects#release-management-strategies-in-large-scale-projects","content":" 1. Unified Release Roadmap​  A release roadmap is a document that covers all key stages and release dates for all teams involved in the project. This allows all teams to see the bigger picture and plan their actions in the context of other teams' work.  Key Elements:  Common goal: The roadmap should reflect the project's ultimate goals and show how each team's work contributes to achieving these goals.Important milestones: Key dates and milestones on the roadmap should be available to all team members so that all stakeholders can track progress and make timely adjustments.Dependencies: It is essential to indicate all dependencies between teams and key integration points to minimize the risk of conflicts and delays.  2. Implementation of a Task Management System​  To manage tasks and coordinate actions between teams, it is necessary to use modern project management tools such as Jira, Asana, or others. These systems help track task progress, manage dependencies, and ensure transparency of all processes. Task management systems can also support integration with Git repositories.  Main Functions:  Task tracker: Creation, assignment, and tracking of tasks with clear deadlines and responsible parties.Dependency management: Using built-in features to manage dependencies, allowing visualization and management of connections between tasks from different teams.Task complexity assessment: Task management systems support various tools for assessing task complexity, helping teams determine their capacity, which improves the reliability of release forecasting.Reports and analytics: Regular progress reports help track task completion and identify potential issues in time.Integration with Git repositories: Integration allows for easy mapping of tasks to changes made in Git, minimizing the risk of untracked changes and ensuring reliable release deployment.  3. Regular Meetings and Team Synchronization​  In large projects, it is crucial to maintain regular communication between all teams. This helps to identify problems promptly, share information, and coordinate actions.  Possible Meeting Types:  Daily stand-ups: Brief team meetings to discuss current tasks and obstacles.Weekly syncs: More detailed meetings to discuss progress on major milestones and dependencies between teams.Strategic meetings: Periodic leadership-level meetings to assess overall strategy and long-term planning.PI Planning (SAFe link): This is a two-day event where teams plan their contribution to value creation for the next Planning Interval (PI), typically lasting 8-12 weeks. PI Planning takes place at the beginning of each PI and plays a key role in synchronizing all teams and participants within the Agile Release Train (ART).  Other types of meetings may be necessary as well, and their choice should be made wisely. The main requirement is that after the meetings, all teams clearly understand their tasks, deadlines, and the impact of their work on other teams. The meetings may also vary depending on the project management framework used.  4. Dependency Management and Integration​  Dependencies between teams and system components are one of the main challenges in large-scale projects. Ignoring them can lead to significant delays and operational failures.  Dependency Management Strategies:  Modular architecture: Where possible, it is necessary to separate the project into independent modules to minimize the number of dependencies.Integration points: Key integration points, where components from different teams must be defined and, if possible, combined, should be identified. Particular attention should be paid to thorough testing of these points. Integration points can also be a source of conflict between teams and departments if interaction mechanisms and areas of responsibility are not determined in advance.Tools for tracking dependencies: Using specialized tools simplifies the control and management of dependencies.  5. Quality Assurance and Testing​  The quality of releases in large projects is of critical importance. Implementing automated testing and CI/CD processes helps ensure high quality and stability of releases.  Approaches to Quality Assurance:  Test automation: Implementing automated testing significantly reduces the cost of errors. Test automation helps identify issues earlier and speed up the testing cycle.Unified testing environment: Use sandbox environments or other isolated environments for integration testing of all system components before deploying to production.Regression testing: It should be conducted regularly in sandbox environments, and after each release. The goal of regression testing is to ensure that new changes have not disrupted the functionality of existing features.  ","version":"Next","tagName":"h3"},{"title":"Benefits and Challenges of Release Management in Large-Scale Projects​","type":1,"pageTitle":"Large-scale Projects","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_05_Large-scale_Projects#benefits-and-challenges-of-release-management-in-large-scale-projects","content":" Benefits:​  Team synergy: Clear release management helps establish coordinated work among all teams, improving coordination and communication.Managed risks: Proper dependency management and testing help minimize risks associated with implementing changes.Process transparency: Using a task management system and regular meetings ensures transparency of all processes and helps identify and address issues promptly.Improved project atmosphere: Teams have a better understanding of responsibilities and tasks, as well as the goals of the project and the business.Increased predictability: Effective release management makes the process more predictable, which is crucial for the business.  Challenges:​  Complexity of coordination: In large projects with many teams and dependencies, coordination is a challenging task.Difficulties in integration: Integrating different components of the system, worked on by various teams, requires careful planning and testing.Change management: Frequent changes can complicate the release management process, especially if there is no clear change management strategy.  ","version":"Next","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Large-scale Projects","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_05_Large-scale_Projects#conclusion","content":" Release management in large-scale projects requires careful coordination, attention to detail, and the use of effective tools and strategies. Proper organization of processes minimizes risks, ensures system stability, and delivers value to users on time. Implementing practices such as creating a unified roadmap, using a task management system, and holding regular meetings helps successfully manage releases even in the most complex and multi-component projects. The right choice of management frameworks can also simplify process management. ","version":"Next","tagName":"h3"},{"title":"Release Management","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_01_Release_Management","content":"","keywords":"","version":"Next"},{"title":"What is Release Management?​","type":1,"pageTitle":"Release Management","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_01_Release_Management#what-is-release-management","content":" Release management is the process of planning, coordinating, and managing software releases, from development and testing to deployment in production. In the context of Salesforce, release management involves overseeing all changes within the platform, whether they are new features, bug fixes, configuration updates, or integrations.  ","version":"Next","tagName":"h3"},{"title":"Why is Release Management Important?​","type":1,"pageTitle":"Release Management","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_01_Release_Management#why-is-release-management-important","content":" System Stability and Reliability:Release management helps ensure the system’s stability by preventing the introduction of errors and failures. This is particularly crucial in large releases, where multiple changes can impact critical business processes. Risk Minimization:Every release carries certain risks. Release management helps minimize these risks through careful planning, testing, and quality control at all stages of the release process. Team Coordination:In large projects involving multiple teams, release management helps coordinate their actions to avoid conflicts and ensure consistency in changes. Quality Assurance:Release management enables a systematic approach to testing and validating changes, helping to maintain a high level of quality in deployed updates. Flexibility and Scalability:In a fast-changing business environment, release management ensures the ability to respond quickly and flexibly to changes, deploying new features as they become ready.  ","version":"Next","tagName":"h3"},{"title":"Key Responsibilities of Release Management​","type":1,"pageTitle":"Release Management","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_01_Release_Management#key-responsibilities-of-release-management","content":" Release Planning:Defining the release schedule, distributing tasks among teams, and aligning with stakeholders. Planning includes risk analysis, impact assessment of changes, and preparation for potential issues. Testing and Validation:Comprehensive testing must be conducted before each release to ensure that changes do not cause system disruptions. In Salesforce, Sandbox environments are used to test changes in an isolated setting. Deployment of Changes:This stage involves deploying changes to production. Depending on the complexity and criticality of the release, various deployment strategies may be used. Monitoring and Feedback:After a release, it is important to monitor how the changes affect the system and collect feedback from users. This helps quickly address potential issues and make adjustments in subsequent releases. Incident Management:In case of issues in production, release management includes clear rollback procedures and incident resolution. Accelerating Delivery:Optimizing the process of delivering new features for the fastest deployment of changes needed by the business.  ","version":"Next","tagName":"h3"},{"title":"The Role of a Release Manager​","type":1,"pageTitle":"Release Management","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_01_Release_Management#the-role-of-a-release-manager","content":" The release manager is a key role responsible for the successful implementation of changes in the system. The responsibilities of this role include:  Coordination: The release manager coordinates the actions of all participants in the process—developers, testers, administrators, and business analysts.Quality Control: The release manager ensures that quality standards are met at all stages of the release.Communication: A significant part of the release manager’s job is maintaining communication between teams and stakeholders and providing timely updates on the release status.Problem Resolution: In the event of incidents, the release manager organizes their prompt resolution, minimizing impact on the business. ","version":"Next","tagName":"h3"},{"title":"Git Flow","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_03_Git_Flow","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"Git Flow","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_03_Git_Flow#implementation-examples","content":" The most popular scheme for the Git Flow strategy is illustrated below.    ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Git Flow","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_03_Git_Flow#advantages","content":" Clear Structure: Git Flow provides a clear and organized branching structure, making development management easier in large teams and complex projects. Parallel Development: Developers can work on different features simultaneously without conflicts by using feature branches. Simplified Release Cycle: Release branches allow thorough testing and preparation of releases, including the latest fixes and metadata, before deploying to production. Effective Hotfix Management: Hotfix branches provide a quick way to fix critical production errors without disrupting the current development cycle. Code Consistency: Back merging hotfix and release branches into the develop branch maintains code consistency. CI/CD Support: The strategy integrates well with continuous integration and deployment practices, ensuring automated testing and deployment.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Git Flow","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_03_Git_Flow#disadvantages","content":" Complexity: For small teams and projects with frequent releases, Git Flow can be overly complex and redundant. Slow Development Cycle: The process of creating and merging branches can slow down the development cycle, especially if quick changes are needed. Additional Overhead: Managing multiple branches requires extra time and effort for synchronization and conflict resolution. Relatively High Learning Curve: New team members may need time to understand and adapt to the Git Flow strategy, especially if they are not familiar with branching and merging concepts.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Git Flow","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_03_Git_Flow#features","content":" Git Flow Strategy is flexible, as the time to prepare a release for deployment to production can vary depending on the complexity of the release. The release branch contains only the code for the upcoming release, simplifying the testing process and code control. Regular merges are necessary for branch synchronization, maintaining code consistency. Developers need to switch between branches depending on tasks, requiring discipline and good organization.  ","version":"Next","tagName":"h3"},{"title":"Ideal Project Profile​","type":1,"pageTitle":"Git Flow","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_03_Git_Flow#ideal-project-profile","content":" Large or Medium-Sized Development Team: Git Flow is best suited for projects involving multiple teams or a large number of developers, as it provides a clear structure for branch management and code synchronization. Projects with Regular Releases: If a project requires regular and scheduled releases, Git Flow helps organize the release process, ensuring code stability and quality. Complex Projects with Long Development Cycles: Git Flow is ideal for complex projects where managing numerous features and fixes that can be developed and tested in parallel is necessary. High Quality Control Requirements: Projects requiring thorough testing and quality control before production release benefit from using release branches for preparation. Multiple Environments (development, staging, production): Git Flow makes it easy to manage multiple environments, simplifying deployment and testing processes across different environments. Support for Complex Development and Release Processes: Projects needing quick production error fixes (hotfixes) without disrupting current development also benefit from Git Flow's structure. CI/CD Practices: Projects actively using continuous integration and deployment will find Git Flow useful for automating testing and deployment through a clear branch structure. ","version":"Next","tagName":"h3"},{"title":"Release on Demand","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_03_Release_on_Demand","content":"","keywords":"","version":"Next"},{"title":"What is Release on Demand?​","type":1,"pageTitle":"Release on Demand","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_03_Release_on_Demand#what-is-release-on-demand","content":" Companies typically need to quickly implement new features and fixes to meet user needs and maintain competitiveness. In such conditions, Release on Demand becomes the best solution for implementing changes. This approach allows for the release of changes as they are ready, without waiting for scheduled release cycles, providing the flexibility businesses need and accelerating the delivery of value to users. It enables companies to adapt more quickly to market changes and respond promptly to user requests.  ","version":"Next","tagName":"h3"},{"title":"Implementing Release on Demand - Key Steps​","type":1,"pageTitle":"Release on Demand","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_03_Release_on_Demand#implementing-release-on-demand---key-steps","content":" Implementing Release on Demand requires a well-organized process and appropriate tools.  1. Integration with CI/CD Processes​  Continuous Integration and Continuous Delivery (CI/CD) play a crucial role in implementing Release on Demand. These processes automate the build, testing, and deployment of changes, enabling teams to release new versions faster and more safely.  Key Steps:  Setting up CI/CD tools: Tools like Jenkins, GitHub Actions, GitLab CI, Gearset, or others can automate the build and deployment process. In Salesforce, it's advisable to use Salesforce DX for metadata management and deployments.Automating Testing: Automated testing within the CI/CD pipeline ensures that each change passes all necessary checks before being deployed to production.  2. Release Management with Feature Flags​  Feature Flags are a powerful tool that allows managing the availability of new features independently of the main release. This enables deploying new functionality to production while activating it only for specific users or groups.  How it Works:  Isolation of Changes: New features are implemented using Feature Flags, isolating them from the main code and limiting their impact on users until the decision is made to activate the new functionality.Controlled Activation: Activation or deactivation of features in production is done through configuration settings, without affecting the rest of the code.A/B Testing: Feature Flags are used for A/B testing and analyzing the effectiveness of new features before their full-scale launch.  3. Phased Rollouts​  Phased Rollouts is an approach that allows gradually implementing changes in production, starting with a small group of users. This minimizes risks and allows quickly identifying potential issues.  Steps for Implementation:  Defining User Groups: Start the deployment with a limited group of users, such as internal employees or the most loyal customers.Monitoring and Analysis: Track performance metrics and user feedback at each stage of the rollout to identify and address issues promptly.Gradual Expansion: Increase the number of users with access to the new features as confidence in the stability and quality of the release grows.  4. Rapid Incident Response​  In a Release on Demand scenario, it's crucial to have a clear plan for dealing with incidents. Quick responses and rollback capabilities are key elements of effective risk management.  Key Measures:  System Monitoring: Implement monitoring tools to track key performance and stability metrics.Rollback Plan: Prepare and regularly update a rollback strategy to minimize the impact in case of deployment failures.User Feedback Collection: Regularly gather feedback from users post-release to ensure no new issues have arisen and that users are satisfied with the changes.  ","version":"Next","tagName":"h3"},{"title":"Benefits and Challenges of Release on Demand​","type":1,"pageTitle":"Release on Demand","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_03_Release_on_Demand#benefits-and-challenges-of-release-on-demand","content":" Benefits:​  Flexibility and Speed: Allows releasing new features and fixes as they are ready, accelerating value delivery to users. Increased Competitiveness: Companies using Release on Demand can respond faster to market changes and implement innovations more quickly. Risk Reduction: Gradual rollouts and the use of Feature Flags help minimize risks associated with the sudden introduction of new features.  Challenges:​  Automation Requirements: Successful implementation of Release on Demand requires the adoption and maintenance of CI/CD processes and automated testing, which demands significant effort and resources. Complexity of Management: Frequent releases require strict coordination between teams and effective change management, which can be challenging in large organizations. Increased Responsibility: Frequent releases require the team to be constantly ready to respond quickly to incidents and resolve issues. Increased Development and Testing Complexity with Feature Flags: Implementing Feature Flags requires additional abstractions in the code and their tracking, complicating development. Testing also needs to cover various feature flag settings, making the process more labor-intensive compared to regular development.  ","version":"Next","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Release on Demand","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_03_Release_on_Demand#conclusion","content":" Release on Demand is a flexible release management approach that enables companies to deliver value to their users faster, without waiting for scheduled release cycles. This method requires careful process organization, automation, and continuous monitoring, but ultimately, it shortens time-to-market and enhances competitiveness. Implementing Release on Demand can be a significant advantage for companies seeking flexibility and innovation in their business. ","version":"Next","tagName":"h3"},{"title":"HotFix","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_09_HotFix","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"HotFix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_09_HotFix#implementation-examples","content":" 1a, 1b - Strategies with backpromotion 2a, 2b - Strategies without backpromotion  It is important to note that the approach is flexible, and hotfixes can occur both in separate branches and in the most suitable branches for this purpose.  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"HotFix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_09_HotFix#features","content":" The main factor in choosing whether to use backpromotion or not is the size of the project and the Git strategy.  Hotfix with BackpromotionOn projects with a large number of teams and a long development and delivery cycle, it is more appropriate to make changes in the branch corresponding to the production state, and then promote the changes to the developer branches. This minimizes the time required to deliver the fix to the production environment. Further promotion of the fix to the developer branches may lead to conflicts, which there will be sufficient time to resolve.  Hotfix without BackpromotionIf the development and delivery cycle on the project is short, it usually makes sense to use the regular development cycle for hotfixes. The likelihood of conflicts when transferring changes to the release branch in this case is minimal. The absence of the need for backpromotion reduces the complexity of branch management and simplifies the development process. ","version":"Next","tagName":"h2"},{"title":"Anti-patterns","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_99_Anti_patterns","content":"Anti-patterns Lack of Clear Structure and Documentation: Implementing Git strategies without clear documentation and structure can lead to chaos. Developers may not understand which branches to use and in what order to merge. Infrequent Branch Synchronization: In strategies with parallel releases or the Fork strategy, infrequent synchronization of branches can lead to numerous merge conflicts and increased time to resolve these conflicts. Ignoring Code Reviews and Testing: Skipping code reviews and testing stages before merging changes into main branches can result in bugs and unstable code being introduced. Lack of Automation: Without automation of processes (CI/CD), managing branches and deploying changes can become labor-intensive and error-prone. Complex Branch Management: Using too many branches without clear necessity can complicate project management and lead to confusion. Insufficient Communication and Coordination: Lack of communication between development teams can lead to duplicated efforts, conflicts, and project delays. Over-reliance on Tools: Complete dependence on specific tools without the ability to replace them can limit team flexibility and complicate adaptation to new conditions. Assuming a Universal Strategy for All Projects: Assuming that the same branching strategy will be ideal for all types of projects can lead to inefficiency and problems in implementation.","keywords":"","version":"Next"},{"title":"Git Strategies","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_01_Strategies","content":"","keywords":"","version":"Next"},{"title":"Why Git is Needed​","type":1,"pageTitle":"Git Strategies","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_01_Strategies#why-git-is-needed","content":" Git is necessary for projects for several reasons:  Version Control: Git allows tracking changes in Salesforce code and metadata. This helps restore any previous version of the code if needed and see who made changes and when. Collaboration: Git simplifies collaboration among multiple developers on a single project. Each developer can work on their own branch without interfering with others. Changes can then be merged into the main branch. Code Reviews: Using Git makes organizing and conducting code reviews easy. This helps improve code quality and identify errors at early stages. Deployment Automation: Integrating Git with CI/CD (Continuous Integration / Continuous Deployment) tools automates the deployment and testing process of changes in Salesforce, speeding up the release of new versions and reducing the likelihood of errors. Security and Backup: Storing code in Git ensures its preservation and availability. Even if a local copy of the code is lost, data can always be restored from the repository. Traceability: Git provides the ability to trace change history, understand the reasons and context for changes, which is especially useful for debugging and problem analysis. Working with Multiple Environments: Salesforce projects often use different environments (Dev, Int, UAT, Prod, etc.). Git helps distribute code across these environments according to the release strategy. Integration with Other Tools: Git easily integrates with various project management tools like Jira, Trello, and others, making project management more convenient and structured.  ","version":"Next","tagName":"h2"},{"title":"Why Git Strategies are Needed​","type":1,"pageTitle":"Git Strategies","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_01_Strategies#why-git-strategies-are-needed","content":" An experienced manager entrusted with working with Git should understand Git strategies. An incorrectly chosen Git strategy can lead to several issues such as disruption of production, poor development quality, conflicts between developers, and project failure.  When choosing a Git strategy for a project, several factors need to be considered to ensure the chosen strategy best meets the requirements and promotes efficient development. Key aspects to consider:  Team Size and Structure Number of Developers: Large projects with many teams and developers may require more complex strategies to manage parallel work, reduce conflicts, and increase efficiency.Team Experience: Less experienced teams may find it easier to work with simpler strategies. Release Frequency Frequent Releases: Projects with frequent releases can benefit from strategies with minimal stages from development to production.Infrequent Releases: Projects with infrequent and large releases and long development cycles are better suited to strategies with additional stages of development verification or splitting development into parallel releases. Type and Scale of Project Small Projects can use simple strategies to avoid unnecessary bureaucracy.Large and Complex Projects require thorough version control and stability, and may need more complex strategies. Need to Support Multiple Versions Projects that need to be maintained in multiple versions simultaneously may require a strategy that includes release and hotfix branches. Integration with CI/CD If the project actively uses continuous integration and deployment tools, the chosen strategy should integrate well with these processes. It's important not to overload the pipeline. Workflows and Methodologies Agile Development Methodologies (Agile, Scrum) may require a strategy that supports frequent and iterative changes.Traditional or Waterfall Methodologies may better align with more formalized strategies. Quality and Testing Requirements If the project requires thorough testing and code review before integrating changes, the strategy should meet these requirements. Code and Dependency Complexity Projects with many dependencies and complex code may need stricter branch management and version control. Need for Quick Bug Response If the project requires quick response to bugs and hotfix releases, the strategy should include mechanisms for creating and integrating hotfix branches.  A Git strategy, like a release strategy, should meet the project's requirements and architecture, ensuring flexibility and reliability.  ","version":"Next","tagName":"h2"},{"title":"Comparison of Git Strategies​","type":1,"pageTitle":"Git Strategies","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_01_Strategies#comparison-of-git-strategies","content":" Strategy\tTeam Size\tRelease Development Cycle Length\tParallel Releases\tSupporting Frequent Deployments\tLevel of Support for Parallel DevelopmentTrunk-Based Development (TBD)\tSmall/Medium\tShort\tNo\tHigh\tLow Git Flow\tSmall/Medium\tShort/Medium\tNo\tMedium\tLow/Medium Copado Branch\tSmall/Medium\tShort/Medium\tNo\tHigh/Medium\tLow/Medium Parallel Releases\tMedium/Large\tShort/Medium/Long\tYes\tMedium\tHigh Fork Strategy\tLarge\tMedium/Long\tYes\tLow\tHigh  ","version":"Next","tagName":"h2"},{"title":"Git Approaches​","type":1,"pageTitle":"Git Strategies","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_01_Strategies#git-approaches","content":" HotFix Feature Branch Org Branch  ","version":"Next","tagName":"h2"},{"title":"Git Fork Strategy","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_06_Fork_Strategy","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"Git Fork Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_06_Fork_Strategy#implementation-examples","content":" The example illustrates three fork projects from the main project. Each developer of the three fork projects works as with a regular project, but merging with the main project occurs through a pull request. This includes quality control and, if necessary, discussions on possible solutions implemented in the fork project.    ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Git Fork Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_06_Fork_Strategy#advantages","content":" Isolation of Changes: Forks allow developers to work on their changes in separate copies of the repository, minimizing the risk of conflicts and errors in the main repository. This is especially useful when developing new features or experimental changes. Code Security: The main repository remains protected from direct changes since all modifications go through a code review process before merging. This enhances security and code quality, as all changes are checked and approved before integration. Development Flexibility: Developers can work on projects independently without affecting the main development branch. This allows teams to work at their own pace and make changes without needing to coordinate with others until the pull request is created. Quality Control: The pull request process includes mandatory code reviews, ensuring high code quality and consistency. It also allows involved developers and teams to discuss and improve changes before merging. Support for External Contributions: The fork strategy simplifies working with external contractors and freelancers, allowing them to make changes in isolated copies of the repository. This helps easily integrate their work after review.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Git Fork Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_06_Fork_Strategy#disadvantages","content":" Increased Overhead: Managing forks and synchronizing changes between forks and the main repository can require additional effort and resources. Regular synchronization and conflict resolution can be time-consuming processes. Management Complexity: In large projects with many forks, it can be challenging to track all changes and pull requests. This requires a well-organized process and management tools. Limited Visibility of Changes: Changes made in forks are not immediately visible to other team members, which can complicate coordination and integration of work. This is especially critical for large and distributed teams. Risk of Desynchronization: Infrequent synchronization of forks with the main repository increases the risk of conflicts and errors during merging. This can complicate the integration process and increase the time needed for conflict resolution. Need for Training and Adaptation: Effective use of the Fork Git Strategy requires team training and adaptation to new processes. This can take time and require additional resources, especially for teams unfamiliar with this strategy.  ","version":"Next","tagName":"h3"},{"title":"Main Steps of Using the Fork Strategy​","type":1,"pageTitle":"Git Fork Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_06_Fork_Strategy#main-steps-of-using-the-fork-strategy","content":" Fork the Main Repository: The developer creates a copy of the main repository in their own account. This allows them to work on the project independently of other developers and without risking damage to the main repository. Clone the Fork: The developer clones their fork to their local machine to start working on the project. Create Feature Branches: The developer creates new branches for each feature or bug fix. This allows for the isolation of changes and easier code management. Development and Commits: The developer makes changes and commits them to their feature branch. Synchronize with the Main Repository: Periodically, the developer synchronizes their fork with the main repository to get the latest changes and minimize conflicts during merging. Pull Request (PR): After completing work on a feature or bug fix, the developer sends a pull request to the main repository, proposing to integrate their changes. This allows the main repository owners to review and discuss the changes before merging.  ","version":"Next","tagName":"h3"},{"title":"Ideal Project Profile​","type":1,"pageTitle":"Git Fork Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_06_Fork_Strategy#ideal-project-profile","content":" Open-Source Project: Description: Ideal for open-source projects where any developer can fork the repository, make their changes, and submit a pull request for review.Advantages: The fork strategy simplifies attracting external contributors and managing their contributions, maintaining a high level of code quality through the code review process. Large or Distributed Development Team: Description: Projects involving large or distributed teams of developers can benefit from change isolation and independent work.Advantages: Developers can work on their features or bug fixes independently, minimizing conflicts and improving change management. Intensive Use of External Contributors: Description: Projects that actively involve external developers, such as freelancers or contractors, to perform tasks.Advantages: Forks allow external developers to make changes in isolated copies of the repository, ensuring the security of the main code and simplifying the integration of their work after review. Complex Corporate Applications: Description: Internal corporate projects with high confidentiality or criticality, where it is important to protect the main code from direct changes.Advantages: The fork strategy provides additional security, as changes go through a review process before merging with the main repository, protecting against unverified changes. Experimental Development and Research (R&amp;D): Description: Projects related to research and development of new technologies, where it is important to isolate experimental features.Advantages: Forks allow researchers to work on experiments independently of the main codebase, minimizing risk to the stability of the main product. ","version":"Next","tagName":"h3"},{"title":"Copado Branching Strategy","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_04_Org_Branch_Copado","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"Copado Branching Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_04_Org_Branch_Copado#implementation-examples","content":" Key implementation features, depicted in the diagram, include feature branches created from the Production branch but containing changes from the Dev environment. Feature branches are created automatically, and Copado allows retrieving changes from selected sandboxes into them. When moving changes to UAT (branch corresponding to the environment), Copado creates a temporary Promotion branch, where selected feature branches can be merged. The merging process is accompanied by validation and deployment of changes to the selected environment. When promoting changes to Production, the process repeats similarly to the promotion of changes to UAT.  The strategy implementation diagram is taken from the official Copado website documentation Link    ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Copado Branching Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_04_Org_Branch_Copado#advantages","content":" Isolation of Changes: Each user story or feature is developed in a separate branch. Branch Automation: Copado automatically creates and manages branches, reducing manual errors and speeding up the development process. Automation also simplifies branch management and the deployment process. Regular Back-promotion: Regular back-promotion support helps synchronize changes between branches, ensuring code consistency and preventing errors. Built-in Quality Gate: Copado includes detailed instructions, recommendations, and tools for integrating quality control into the delivery strategy. Environment-Specific Branches: The strategy includes branches corresponding to environments, making it easy to track code and changes for the respective environment.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Copado Branching Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_04_Org_Branch_Copado#disadvantages","content":" Management Complexity: Despite automation, managing many branches can be challenging, especially in large projects with many developers. Clear processes must be organized to avoid chaos in branch management. Tracking Changes Complexity: Changes are recorded in a feature branch created from the base branch (usually the Production branch). This approach adds complexity, as changes in commits may not match those made by the developer during extended feature development or with a large number of developers. Merge Conflicts: Despite isolating changes, merge conflicts can still occur. In complex projects, conflicts are common due to the nature of forming commits in the feature branch. Release Formation Complexity with Many Tickets: When moving a large number of tickets after forming a promotion branch from the target branch, feature branches are merged sequentially. This process can be time-consuming and unpredictable when conflicts are present. Training and Adaptation: Effective use of the strategy requires team training and adaptation to new processes, which can take time and additional resources. Tool Dependency: High integration with specific tools can create dependency and complicate the transition to other solutions in the future. Inability to significantly influence Git strategy changes, as it is part of Copado, can cause issues if tools are updated or changed.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Copado Branching Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_04_Org_Branch_Copado#features","content":" Copado Branching Strategy is an integral part of Copado. Copado offers a comprehensive solution and significant automation in managing changes, development processes, and deliveries but requires a careful approach to team training and process organization to achieve maximum efficiency. Release management, automation, and Git strategy are carried out through Salesforce.  ","version":"Next","tagName":"h3"},{"title":"Ideal Project Profile​","type":1,"pageTitle":"Copado Branching Strategy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_04_Org_Branch_Copado#ideal-project-profile","content":" Small or Medium Projects: Copado is ideal for projects with a limited number of teams or developers, as the complexity of release management increases sharply with more teams and developers. Frequent and Small Releases: Projects requiring frequent and regular releases benefit from using Copado, as it better manages changes and maintains high code quality through centralized management and process automation, minimizing conflicts related to the strategy. High Code Quality and Testing Requirements: Projects where thorough testing and quality control are critical can effectively use Copado's capabilities for test automation. Complex Infrastructure: Projects with multiple development environments (development, staging, production) benefit from centralized change management offered by Copado, simplifying the deployment process and synchronization of changes between different environments. ","version":"Next","tagName":"h3"},{"title":"Feature Branch","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_08_Feature_Branch","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"Feature Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_08_Feature_Branch#implementation-examples","content":" Since feature branches typically exist for a long time, periodic updates from the base branch using the merge process can be applied. This allows developers to obtain the current version of the metadata, which may have been changed while they were working on the feature. Before merging the feature branch into the main branch, it is also recommended to update the feature branch for testing and validating the current metadata. In case of conflicts, the developer can resolve them locally and test the solution. The example shows implementation scenarios:  ","version":"Next","tagName":"h2"},{"title":"Advantages​","type":1,"pageTitle":"Feature Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_08_Feature_Branch#advantages","content":" Change Isolation: Each new feature is developed in a separate branch, allowing for isolation of changes and minimizing impact on the main branch. Quality Gate: Before merging the feature branch with the main branch, changes undergo code review and testing, helping to maintain code quality and reduce the likelihood of errors. Development Flexibility: Developers can work on their features independently and at their own pace, boosting productivity and efficiency. Simplified Management: The strategy makes it easy to track progress on each feature and manage changes, simplifying the development and deployment process. Easy Rollback of Changes: If a new feature causes problems, changes can be easily rolled back by reverting the merge commit. Scalability: The Feature Branch strategy scales well to projects of any size, allowing each developer or team to work on their features independently.  ","version":"Next","tagName":"h2"},{"title":"Disadvantages​","type":1,"pageTitle":"Feature Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_08_Feature_Branch#disadvantages","content":" Integration Delays and Synchronization Gaps: Isolated development can lead to delays in integrating changes and losing synchronization with the main branch, especially if branches exist for a long time. This increases the risk of conflicts during merging and complicates management. Dependency Management Challenges: In complex projects with many feature branches, managing dependencies between various features can become problematic. Increased Code Review Workload: Feature branches can contain a large volume of changes, making code review significantly more complex when opening a merge request.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Feature Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_08_Feature_Branch#features","content":" To address the shortcomings like the feature branch lagging behind the main branch, it is recommended to update it through merging. This is demonstrated in the implementation examples section. Updates should occur as needed, considering the project's specifics.  ","version":"Next","tagName":"h2"},{"title":"Ideal Project Profile​","type":1,"pageTitle":"Feature Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_08_Feature_Branch#ideal-project-profile","content":" Medium or Large Development Team: The Feature Branch strategy is well-suited for projects working on multiple features simultaneously, allowing each developer or team to work independently. Modular Architecture: The project should be divided into modules or components, allowing for changes to be isolated and minimizing conflicts when merging branches. Active Use of Version Control Systems (VCS): Modern systems like Git facilitate the creation, management, and merging of feature branches. Continuous Integration (CI) and Quality Gate: Having a configured CI system that automatically runs tests and checks for each feature branch helps maintain high code quality and reduces the risk of integration issues. Strong Code Review Culture: Mandatory code reviews before merging feature branches with the main branch help maintain code quality and enhance collective responsibility for the codebase. Effective Dependency Management: The project should use tools and processes to manage dependencies between different feature branches, minimizing risks when integrating changes. Flexible Development Methodologies: Using flexible methodologies like Scrum or Kanban helps adapt the development process to current tasks and changing requirements. Management Support: Management should support the implementation of the Feature Branch strategy by providing necessary resources and creating conditions for effective team work. High Level of Test Automation: Having automated tests (unit tests, integration tests, UI tests) for each feature branch helps quickly identify and fix errors. ","version":"Next","tagName":"h2"},{"title":"Release Planning","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_02_Release_Planning","content":"","keywords":"","version":"Next"},{"title":"Objectives of Release Planning​","type":1,"pageTitle":"Release Planning","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_02_Release_Planning#objectives-of-release-planning","content":" Release planning allows you to:  Structure the process of implementing changes.Minimize the risks associated with deployment.Ensure that all tasks are completed within established deadlines.Successfully integrate with necessary systems.  ","version":"Next","tagName":"h3"},{"title":"Key Steps in Release Planning​","type":1,"pageTitle":"Release Planning","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_02_Release_Planning#key-steps-in-release-planning","content":" 1. Defining Release Windows​  A release window is a pre-planned time frame during which a release is deployed. In Salesforce projects, release windows are often determined based on the company’s business cycle or user needs. To minimize the impact on employee workflows, releases may be scheduled during periods of low activity (outside of working hours or on weekends).  Factors to consider when choosing a release window:  Impact on business processes: How will the changes affect current operations? It’s important to choose a time when the potential impact will be minimal.Dependencies on other projects: The release may depend on the completion of other initiatives.Availability of the team: Ensure that all key participants, including developers, testers, and administrators, are available to support the release.Duration of activities: There should be enough time for deploying the release, testing, and applying corrective measures if issues are discovered.  2. Coordination with Stakeholders​  Effective release planning requires close coordination among all project participants. It’s important to establish clear communication channels, define areas of responsibility, and assign accountable personnel, especially for large projects.  Key steps in coordination:  Defining roles and responsibilities: Team members must clearly understand their roles in the release process if they are involved. This includes who is responsible for developer support, testing, deployment, and monitoring.Regular meetings: Holding regular status meetings helps track progress and quickly resolve any issues that arise.Agreeing on deadlines: All participants should agree on the deadlines for their tasks to avoid delays and conflicts during the merge.Assigning a primary communication channel: It’s important to designate a communication channel and ensure it’s accessible to all stakeholders. A good practice is to develop message templates for various stages of release preparation and deployment. It may also be useful to assign separate communication channels for different stages to simplify communication with various groups of stakeholders.  3. Risk Assessment​  Risk assessment is a crucial part of release planning as it helps anticipate potential problems and develop contingency plans.  Factors to consider in risk assessment:  Complexity of changes: The more changes there are, the higher the likelihood of errors.Dependencies: Identifying dependencies ensures the necessary testing of dependent systems and determines additional actions if needed.Code quality: Thorough testing in sandbox environments is essential. Automated tests help identify potential issues early, reducing the cost of errors.Readiness for rollback: Developing a rollback plan in case something goes wrong is a mandatory part of risk management. The rollback should ensure the most reliable and quickest way to return to the previous stable production version.Presence of manual steps: When deploying a release, it’s important to consider the possibility of performing both pre-deployment and post-deployment manual steps. A reliable and understandable system for recording and tracking manual steps is necessary. It’s crucial to automate manual steps as much as possible, especially repetitive tasks.  4. Resource Planning​  Resource planning involves determining the necessary resources for the successful completion of the release, including people, technology, and time.  Key aspects of resource planning:  Team resources: Determine how many people will be needed at each stage of the release and ensure their availability.Tools and technology: Ensure that the team has access to all the necessary tools, technologies, and environments.Timeframes: Break the release into stages and set clear deadlines for each, taking into account potential delays.Communication channels: Using a communication channel for coordinating the actions of employees and stakeholders involved in the release is essential for successful coordination. A clear plan for using the communication channel is also necessary to ensure that information is accessible and correctly distributed among participants.  ","version":"Next","tagName":"h3"},{"title":"Coordinating Releases with Multiple Teams​","type":1,"pageTitle":"Release Planning","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_02_Release_Planning#coordinating-releases-with-multiple-teams","content":" In large projects, several teams are often involved, each responsible for its own scope of tasks. In such conditions, coordination becomes critically important.  Tips for coordination:  Shared roadmap: Create a shared release roadmap so that all teams can see how their work fits into the overall process.Task management system: Use project management systems (e.g., Jira, Trello) to track the progress of each team’s tasks and timely identify potential conflicts.Agreed-upon processes: Ensure that all teams work according to agreed-upon processes, including standard procedures for testing, code review, and deployment.Regular meetings: Regular meetings, for example, between tech leads, help better coordinate actions between development teams and minimize dependency risks.  ","version":"Next","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Release Planning","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_01_Release/02_01_02_Release_Planning#conclusion","content":" Release planning is a multifaceted process that requires careful attention and coordination of efforts from all project participants. The success of a release depends on the correct selection of release windows, effective team coordination, thorough risk assessment, and thoughtful resource planning. By following these principles, you can minimize risks, improve release quality, and ensure the stability of the system. Successful release planning contributes to the overall growth and efficiency of the team, enhancing trust in the development and change implementation processes. ","version":"Next","tagName":"h3"},{"title":"Automation of Deployment","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_02_Automation_of_Deployment","content":"","keywords":"","version":"Next"},{"title":"Benefits of Deployment Automation​","type":1,"pageTitle":"Automation of Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_02_Automation_of_Deployment#benefits-of-deployment-automation","content":" Ensures Reliability and Consistency Automated deployment processes significantly reduce the risk of errors caused by human factors. This is especially crucial for large projects, where even minor errors can lead to serious disruptions. Automation ensures that all steps are executed in the correct sequence with accurate configurations, maintaining system stability.Reduces Deployment Time Manual deployment requires time for preparation, verification, and execution, which can cause delays, especially with frequent updates. Automation enables faster deployments, reducing the time required to release new versions and easing the workload on developers and administrators.Improves Version Control Automated deployment tracks all changes in a version control system (e.g., Git), ensuring transparency and enabling rollbacks to previous versions. This is especially important for quickly recovering from failed deployments or managing parallel branches.Supports CI/CD Processes Deployment automation is a key element of CI/CD (Continuous Integration and Continuous Deployment), allowing development teams to regularly integrate changes into the main codebase, automatically test them, and deploy them across environments. This improves code quality and accelerates development.Reduces Dependence on Manual Labor In large projects or frequent updates, manual deployment can become a bottleneck as only a few specialists may be responsible for the process. Automation eliminates this dependency, making deployments more accessible and manageable for all team members.Enhances Flexibility and Scalability Automation makes it easy to deploy changes across multiple environments (e.g., sandbox and production). Automation tools can support different configurations for each environment, ensuring scalability and reducing the need for manual adjustments.Ensures Consistency and Standardization Automated processes standardize all deployment steps, helping to maintain uniform configurations across environments. This reduces the likelihood of unexpected issues when transitioning from one environment to another.Implements Quality Gates Automation often includes automated testing (unit tests, integration tests, etc.), which helps identify potential issues before deploying changes to environments. This reduces the risk of failures, improves the quality of releases, and lowers the cost of fixing errors.  ","version":"Next","tagName":"h2"},{"title":"Tools and Platforms for Deployment Automation in Salesforce​","type":1,"pageTitle":"Automation of Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_02_Automation_of_Deployment#tools-and-platforms-for-deployment-automation-in-salesforce","content":" Modern CI/CD tools designed for Salesforce support automation at every stage of deployment and testing. When building automation processes, it's important to evaluate the capabilities, strengths, and weaknesses of available systems. Tools for automation can be divided into two main categories:  Pre-built third-party solutions specifically designed or adapted for Salesforce. Examples include Gearset, Copado, and Autorabit.Custom-built solutions, which require specialized knowledge for development and operation but can be the most effective for specific project requirements. These solutions use Salesforce CLI and can be automated with DevOps tools like GitLab CI, GitHub Actions, Jenkins, Azure DevOps, and others.  ","version":"Next","tagName":"h2"},{"title":"The Importance of Considering End-to-End Processes and Business Needs​","type":1,"pageTitle":"Automation of Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_02_Automation_of_Deployment#the-importance-of-considering-end-to-end-processes-and-business-needs","content":" Deployment automation is not just about choosing the right tools and configuring technical processes. Effective automation requires understanding the full end-to-end process and considering the needs of the business, stakeholders, and users. Automation focused solely on technical aspects can lead to overengineering, where solutions become overly complex and costly for the business without clear benefits.  It is essential for automation to enhance not only technical processes but also achieve the overall project goals. This requires an understanding of processes and collaboration with business users and stakeholders to ensure that new processes and automation support the real needs of the organization, improve user experience, and add value to the business. ","version":"Next","tagName":"h2"},{"title":"Quick Deploy","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_06_Quick_Deployment","content":"","keywords":"","version":"Next"},{"title":"Advantages​","type":1,"pageTitle":"Quick Deploy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_06_Quick_Deployment#advantages","content":" Time Savings on Deployment: Quick Deploy allows skipping test execution if validation was successful, significantly reducing overall deployment time, especially for large projects with many tests.Preparation of Change Package: Quick Deploy and prior validation provide the team with as much preparation time as needed without impacting the target environment. Successful validation allows for a subsequent fast deployment.Deployment Planning: Quick Deploy allows teams to detect errors in advance and prepare changes for deployment at a scheduled time, minimizing business impact. This is particularly relevant for large-scale changes and when additional production testing is required.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Quick Deploy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_06_Quick_Deployment#disadvantages","content":" Limited Usage Window: Quick Deploy is only available for a few days after successful validation, requiring careful release planning, especially for projects with infrequent releases.Risk of Outdated Test Results or Environment State: Quick Deploy relies on previously executed test results. If there are untested changes in the target environment, issues may arise. Metadata changes in the target environment can also cause errors when attempting Quick Deploy.Requirement for Prior Testing: Quick Deploy requires successful validation with full testing, so it cannot be used without preliminary validation.  ","version":"Next","tagName":"h3"},{"title":"When It’s Justified​","type":1,"pageTitle":"Quick Deploy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_06_Quick_Deployment#when-its-justified","content":" Quick Deploy is appropriate for deployments involving a large volume of changes or a substantial number of tests. Validation and subsequent Quick Deploy allow for scheduling deployment in the target environment in advance. This is especially useful if deployment timing is critical, as testing can be completed ahead of time, reducing overall deployment time within the designated timeframe.  ","version":"Next","tagName":"h3"},{"title":"Using Quick Deploy​","type":1,"pageTitle":"Quick Deploy","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_06_Quick_Deployment#using-quick-deploy","content":" When running validation with test execution using the command: $ sf project deploy validate --manifest &lt;path/to/package.xml&gt; --target-org &lt;alias&gt; --test-level RunSpecifiedTests --tests &lt;test name&gt; or $ sf project deploy validate --manifest &lt;path/to/package.xml&gt; --target-org &lt;alias&gt; --test-level RunLocalTests Note: (examples provided use deployment with --manifest, but --source-dir can also be used).  You will receive a Deployment ID, and if validation is successful, you can use this ID to initiate a Quick Deploy. To do this, use the command: sf project deploy quick --job-id &lt;Deploy ID&gt;   You can also use the UI for a manual launch. To do this, go to Setup &gt; Deployment Details and click Quick Deploy from the list of successful deployments/validations:or navigate to the deployment page itself:This will trigger a deployment with a new ID, but without running tests again. ","version":"Next","tagName":"h3"},{"title":"Destructive Change","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change","content":"","keywords":"","version":"Next"},{"title":"Technical Implementation of Destructive Changes​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#technical-implementation-of-destructive-changes","content":" The destructive-changes command is used as an addition to the deployment command, allowing for metadata deletion. There are two options for this:  --post-destructive-changes--pre-destructive-changes  After the flag, you need to specify the path to a package.xml file (the filename can be customized, such as destructiveChangesPre.xml) containing the metadata to be deleted.  For example: $ sf project deploy start --manifest path/to/package.xml --target-org my-org --post-destructive-changes path/to/destructiveChangesPost.xml   Note: In this command, --manifest path/to/package.xml can be empty, containing no metadata. In such cases, only the destructive changes will be executed.  ","version":"Next","tagName":"h2"},{"title":"Executing Destructive Changes Before Deployment​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#executing-destructive-changes-before-deployment","content":" Running destructive changes before the main deployment removes unnecessary components from the target environment before updating the remaining ones. This method is useful when:  The team wants to clean the environment of outdated or conflicting components before introducing new functionality.Space is needed for components that will be updated or replaced in the current deployment.When there are dependencies on new components that need to be overridden or updated.In deployments with significant changes to the metadata structure, where it’s important to clear the environment of conflicting components in advance.  ","version":"Next","tagName":"h2"},{"title":"Advantages​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#advantages","content":" Reduced Deployment Conflicts: Removing unnecessary or conflicting components before deployment helps avoid conflicts associated with creating new versions of components.Environment Cleanliness: Clearing outdated components before deployment keeps the environment up-to-date, simplifying metadata management.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#disadvantages","content":" Risk of Removing Necessary Components: There must be certainty that the components marked for deletion are no longer needed. Otherwise, essential metadata may be inadvertently removed.Complex Deployment Preparation: Thorough testing is required to confirm that no dependencies exist that could cause failures.  ","version":"Next","tagName":"h3"},{"title":"Executing Destructive Changes After Deployment​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#executing-destructive-changes-after-deployment","content":" This approach involves removing components after the main deployment. It is beneficial when it’s essential to implement updates first and then remove unnecessary components to ensure the new code and metadata work correctly. This method is useful when:  After successful implementation of the main functionality, to ensure that component removal does not lead to system failures.In deployments requiring a smooth transition with the option to restore deleted components in case of unforeseen issues.When additional testing of the main deployment is needed before removing redundant components.  ","version":"Next","tagName":"h2"},{"title":"Advantages​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#advantages-1","content":" Reduced Risk of Critical Changes: The main deployment first updates the system, and only then are unnecessary components removed, reducing the risk if deleted components are still needed.Smoother Transition: Executing destructive changes after deployment provides a smoother transition, as priority is given to adding new functionality rather than removing outdated parts.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#disadvantages-1","content":" Potential Conflicts with Updated Components: If destructive changes were not planned in advance, conflicts could arise after implementing new functionality.  ","version":"Next","tagName":"h3"},{"title":"Destructive Changes as a Separate Process​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#destructive-changes-as-a-separate-process","content":" In some cases, it makes sense to perform destructive changes as a separate process. This is justified, for example, when a large cleanup of outdated components is needed, separate from the main deployment.  ","version":"Next","tagName":"h2"},{"title":"Advantages​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#advantages-2","content":" Reduced Risk to Other Processes: Destructive changes are carried out independently, reducing the risk to the current version.Flexibility: The team has more freedom to plan and initiate destructive changes as needed, without linking them to main releases.Simplified Testing and Control: A separate process makes it easier to control component removal and allows for easy restoration of deleted metadata if necessary.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#disadvantages-2","content":" Additional Support and Control Required: Extra resources and time are needed to carry out destructive changes, which may prolong the environment maintenance process.Need to Track Dependencies: Destructive changes performed separately may impact other components if strict dependency control is not ensured.  ","version":"Next","tagName":"h3"},{"title":"When It’s Justified​","type":1,"pageTitle":"Destructive Change","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_05_Destructive_Change#when-its-justified","content":" For routine cleanup of outdated or unnecessary components not tied to main releases.When there is a significant volume of destructive changes that are challenging to integrate into the main deployment.When changes are unrelated to new functionalities and are necessary to maintain order in the environment. ","version":"Next","tagName":"h3"},{"title":"Parallel Releases","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_05_Parallel_Releases","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"Parallel Releases","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_05_Parallel_Releases#implementation-examples","content":" The diagram shows two possible implementations of the strategy. Tags display the versioning example of the release on production: major release/minor release/fix.  The first diagram shows an example with three parallel releases. In this implementation, the release order is pre-agreed, but release development can take a long time.The second diagram shows an example with a minor and a major release. The minor release is more frequently deployed to production. The major release can take a long time.    ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Parallel Releases","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_05_Parallel_Releases#advantages","content":" Isolation of Changes: Each product version is developed in its separate release branch, minimizing the risk of conflicts and simplifying testing. Support for Multiple Versions: The strategy allows simultaneous support and development of multiple product versions, which is especially useful for long-term projects and products with multiple active versions. Flexibility in Release Management: The ability to work on different releases in parallel allows for more flexible responses to changing requirements and priorities. Simplification of the Release Cycle: Separating branches for different releases simplifies the preparation and testing process before release.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Parallel Releases","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_05_Parallel_Releases#disadvantages","content":" Complexity of Branch Management: Maintaining a large number of branches requires careful planning and is a labor-intensive task. Increased Risk of Conflicts: Although isolation of changes minimizes conflicts, synchronization and frequent merges between branches can still lead to conflicts that require resolution. Increased Overhead: Managing multiple release branches may require more resources and time for synchronization and testing. Need for Strict Discipline: Successful application of the strategy requires the team to strictly follow established processes and branch management rules. Potential Complexity in Testing: Testing changes in multiple parallel branches can be challenging and require additional efforts to ensure code quality.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Parallel Releases","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_05_Parallel_Releases#features","content":" A key feature of this strategy is the ability to develop different functionalities in parallel, allowing teams to work on different versions of the product simultaneously. This enables parallel work for a large number of teams and developers, which is especially useful for large and complex projects. Regular synchronizations and merges between branches are necessary to ensure code consistency. This requires a well-constructed release architecture and synchronization process automation. In such strategies, it is important to consider the architectural features of the solutions and ensure that synchronization and merging processes do not disrupt other teams' work. It is also necessary to implement tools for automation and monitoring to simplify the management of multiple parallel branches and minimize the risk of conflicts and errors.  ","version":"Next","tagName":"h3"},{"title":"Ideal Project Profile​","type":1,"pageTitle":"Parallel Releases","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_05_Parallel_Releases#ideal-project-profile","content":" Large or Medium-Sized Development Team: The Parallel Release strategy is especially useful for projects where multiple teams or a large number of developers are working, as it allows them to work on different features and releases simultaneously without interfering with each other. Complex Projects with Long Development Cycles: Projects that require support and development of multiple product versions simultaneously are ideal for this strategy. This includes products with long-term support, where updates and fixes for older versions need to be released while developing new features for future releases. High Requirements for Code Quality and Stability: In projects with parallel releases, it is possible to control code quality more carefully by testing and stabilizing each release branch before merging it into the main branch. This is especially important for projects where code stability and quality are critical. Complex Infrastructure and Multiple Environments: Projects with multiple environments (development, staging, production) benefit from using parallel releases, as this allows managing different product versions and testing them in various environments without interfering with the main development process. Frequent Releases and Updates: Projects that require regular and frequent releases can effectively use this strategy to manage multiple parallel branches, allowing faster responses to changes and release updates. Intensive Integration with CI/CD: Projects that actively use continuous integration and deployment can easily integrate synchronization and testing processes for multiple branches, simplifying the management of parallel releases and improving automation. ","version":"Next","tagName":"h3"},{"title":"Org Branch","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_07_Org_Branch","content":"","keywords":"","version":"Next"},{"title":"Implementation Examples​","type":1,"pageTitle":"Org Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_07_Org_Branch#implementation-examples","content":" The example illustrates the strategy's implementation in a project that uses the Develop, UAT, and Staging environments.  Branches/Environments:  Develop/Integration: A branch for integrating changes developed by developers. This branch is used for merging all features and fixes before they are moved to testing.UAT: A branch for User Acceptance Testing. In this branch, users check functionality and compliance with requirements.Staging: A branch for final testing before production. Final checks and validations take place here.Production/Main: The main branch containing stable code ready for production deployment.    ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Org Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_07_Org_Branch#advantages","content":" Transparency and Control: Clear separation of branches by environment provides better transparency and control over changes. Teams can more easily track which changes have been deployed to each environment and which are in testing. Risk Reduction: Isolating changes in the corresponding branches minimizes deployment risks. Changes go through several stages of testing (Develop, UAT, Staging, Production) before reaching production. Improved Testing: Having separate branches for different testing stages allows for more thorough code testing at each stage. UAT and Staging branches provide the opportunity for user and final testing. Flexibility in Change Management: The ability to work independently on different branches allows for more flexible change and release management. This is particularly important for urgent fixes or working on multiple features simultaneously. Simplification of CI/CD Processes: It is easier to set up and automate continuous integration and deployment processes for each environment.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Org Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_07_Org_Branch#disadvantages","content":" Branch Management Complexity: Managing a large number of branches requires careful planning and can be labor-intensive, especially for large teams and projects. Increased Overhead: Regular synchronization and management of multiple branches increase project management overhead. This may require additional efforts to automate processes. Need for Strict Discipline: Successful application of the strategy requires the team to strictly follow established processes and branch management rules. Violating these rules can lead to chaos and code quality issues.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Org Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_07_Org_Branch#features","content":" The main feature of the strategy is that each branch corresponds to a specific environment, simplifying change management, tracking, and CI/CD setup. This approach ensures isolation of changes at each development and testing stage, minimizing risks and improving code stability.  ","version":"Next","tagName":"h3"},{"title":"Ideal Project Profile​","type":1,"pageTitle":"Org Branch","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_02_Git/02_02_07_Org_Branch#ideal-project-profile","content":" Large or Medium Development Team: The strategy is especially useful for projects where multiple teams or a large number of developers work in parallel, allowing them to isolate their changes in corresponding branches and minimize conflicts. Complex Projects with Long Development Cycles: Ideal for complex projects that require multiple rounds of testing and stabilization at various stages before production deployment. Projects with High Quality and Security Requirements: For projects where code quality and security are critical (e.g., financial applications or medical software), this strategy allows for multi-stage verification before deployment. Projects with Multiple Environments (Development, Staging, Production): For projects developed and tested in multiple environments, it is important to clearly isolate changes and manage code versions. ","version":"Next","tagName":"h3"},{"title":"Types of Packages in Salesforce","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages","content":"","keywords":"","version":"Next"},{"title":"Unlocked Packages​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#unlocked-packages","content":" Unlocked Packages are a Salesforce feature designed for modular development, dependency management, and metadata versioning. Unlike traditional approaches, where all code is stored in a single project, unlocked packages allow functionality to be divided into independent packages that can be deployed, updated, and managed separately. This approach is especially beneficial for large projects and projects with frequent updates, as it enhances code structure, simplifies dependency management, and enables version control.  Unlocked Packages are supported in both Salesforce DX and the Salesforce CLI, allowing them to integrate into CI/CD processes and automate package management. They organize development at a higher level, providing modularity, update flexibility, and improved integration with CI/CD processes.  ","version":"Next","tagName":"h2"},{"title":"Advantages​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#advantages","content":" Modularity and Code Structuring: Unlocked packages allow dividing a project into independent modules, making the code more structured and enabling teams to work on different packages simultaneously, reducing conflict risk and simplifying code management.Version Control and Rollback Capabilities: Each package can be versioned, allowing tracking changes, reverting to previous versions, and managing updates flexibly. This aids in version control and simplifies rollback processes when necessary.Flexibility in CI/CD Processes: Unlocked packages integrate easily into CI/CD processes, enabling automated creation and deployment of packages. This facilitates releasing updates as individual packages are ready, accelerating development and improving release management.Deployment Optimization: Since unlocked packages can be deployed independently, deployments become faster and more manageable, reducing the time for changes and the risk of dependency or code conflicts.Dependency Management: Unlocked packages support dependency management between modules, simplifying work with large projects and preventing conflicts between components. This also improves control over change implementation as each dependency is explicitly defined.Quick Production Deployment of Changes: Development of unlocked packages includes promotion based on successfully created versions with test runs, eliminating the need for production test execution, saving time during production deployments.Solution Scalability: The same version of a package can be installed across various production environments, making it easy to distribute solutions within a company across different regions, for example.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#disadvantages","content":" Complex Setup Requirements: Implementing unlocked packages requires initial project structuring and dependency management setup. For teams unfamiliar with the modular approach, transitioning to unlocked packages may take time and require code structure adjustments.Potential Dependency Issues: Managing dependencies requires careful oversight, especially in large projects, as numerous or improperly defined dependencies can lead to errors.Package Content Limitations: Unlocked packages do not support certain metadata types and may have content restrictions, meaning that some functionality cannot be isolated into separate packages, leaving parts of the code outside packages. You can find the current list of supported metadata at the following - Metadata Coverage ReportVersion Management Complexity with Many Packages: Managing versions across numerous unlocked packages can become challenging as each version and inter-package dependency must be tracked, increasing the team’s workload, particularly if the project evolves rapidly.Limited Adaptability for Different Production Environments: Unlocked packages have restricted metadata modification capabilities in the environment. When installing a new version, any local metadata changes will be overwritten by the package version.  ","version":"Next","tagName":"h3"},{"title":"When It’s Justified​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#when-its-justified","content":" Unlocked packages are especially useful in the following situations:  Large and Complex Projects: In large projects with numerous modules, unlocked packages help structure code and manage changes by dividing the project into independent parts.Frequent Updates and Parallel Development: Unlocked packages allow teams to work on different modules simultaneously and release updates as they become ready, making development more flexible and accelerating releases.Projects with Many Dependencies: If a project involves numerous component dependencies, unlocked packages help manage these dependencies, making them explicit and controllable.Need for Version Rollback: Unlocked packages make it easy to roll back specific changes if errors or functionality issues arise, as each package has a separate version history.  Additional article on unlocked packages  ","version":"Next","tagName":"h3"},{"title":"Managed Package​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#managed-package","content":" A Managed Package in Salesforce is designed for distributing applications and components via AppExchange or for internal use with the ability to update. Managed packages are created with full version control, allowing developers to release updates and patches to users without affecting their data and settings. These packages are closed for code modification, ensuring intellectual property protection and preventing functional interference.  Managed Packages are commonly used for commercial distribution when a developer wants to deliver a ready-made solution to customers via AppExchange, with update capabilities, or for projects requiring strict version control and security. These packages are developed in special DevHub and packaging organizations in Salesforce, ensuring standardization and protection.  ","version":"Next","tagName":"h2"},{"title":"Advantages​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#advantages-1","content":" Intellectual Property Protection: Code in a Managed Package is protected and inaccessible for modification by end users, allowing developers to safeguard their code and ensure functionality is used as intended without risk of alteration.Version Control and Update Support: Managed packages have built-in versioning systems that enable releasing new versions, updating existing ones, and managing their availability for end users, facilitating easy distribution of updates and patches.Marketing and Distribution through AppExchange: Managed packages can be distributed via AppExchange, making them an excellent solution for companies developing applications for a broad Salesforce audience. This channel simplifies marketing and extends reach for developers.Security and Functionality Control: Managed packages allow developers to control package component access, hiding internal code and configuration from users, preventing accidental or intentional changes and ensuring application stability.Business Flexibility and License Management: Managed packages support licensing and trial versions, enabling subscriptions, controlled distribution, and trial periods, allowing users time to explore the product.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#disadvantages-1","content":" Code Closure and Limited Customization: End users cannot modify code or internal settings in managed packages, which limits customization possibilities, posing a challenge for clients needing functional flexibility and adaptation.Complex Version Management: Although managed packages have built-in versioning, handling multiple versions and patches requires careful oversight, as each new version must be compatibility-checked and may require extensive testing.Dependency on the Package Developer: All updates and patches must be provided by the package developer, creating dependency on the vendor. If the developer discontinues support, clients lose access to updates or fixes.AppExchange Certification Requirements: To list a managed package on AppExchange, it must be certified by Salesforce, which requires additional resources and time, especially for large or complex applications. Certification also mandates compliance with Salesforce security and functionality standards.Lack of Direct Access to Code for Debugging: When issues arise, end users cannot modify managed package code for debugging, which complicates troubleshooting. Clients must rely on the developer for resolution.  ","version":"Next","tagName":"h3"},{"title":"When It’s Justified​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#when-its-justified-1","content":" Managed packages are appropriate in the following cases:  Commercial Application Distribution: Managed packages are ideal for developers and companies looking to distribute their solutions to Salesforce customers via AppExchange, offering code protection and revenue opportunities.Security and Control: Managed packages are an excellent choice for applications requiring security and control over functionality, ensuring users cannot interfere with source code or functionality, preventing errors.Subscription-Based Business Models: Managed packages support licensing and trial versions, making them suitable for subscription-based or paid applications that require access control and trial periods.Need for Updates and Support: Managed packages are suitable for projects requiring regular updates and support, as their version control system enables new feature, patch, and update releases without complex procedures.  ","version":"Next","tagName":"h3"},{"title":"Unmanaged Package​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#unmanaged-package","content":" An Unmanaged Package in Salesforce allows distributing components and metadata without version control or update capability. Unlike managed and unlocked packages, an unmanaged package provides open access to source code and configuration after installation, enabling recipients to modify and adapt package components in the target environment. This type of package is often used for templates, instructional examples, and trial solutions that do not require developer support or updates.  Unmanaged packages offer a simple, convenient way to distribute metadata and solutions that users can freely adapt and modify post-installation.  ","version":"Next","tagName":"h2"},{"title":"Advantages​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#advantages-2","content":" Free Editing: Unmanaged packages provide complete access to components post-installation, allowing users to edit and adapt them, making them suitable for customization to specific business needs.Ideal for Education and Template Distribution: Unmanaged packages are perfect for providing educational resources, trial solutions, and templates that users can explore and adapt without requiring developer support.Ease of Use: Since unmanaged packages do not require version control or dependency management setup, they are easy to create and convenient for quick solution distribution among users.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Types of Packages in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_07_Packages#disadvantages-2","content":" No Version Control or Updates: Unmanaged packages do not support versioning, so developers cannot update them post-installation. Changes to code or metadata are not propagated to already installed packages, limiting long-term use.Low Level of Code Control: As all package components become editable, source code and configurations can be modified or deleted by the recipient, affecting the developer's original design and complicating support.Unsuitable for Large-Scale Solutions: Unmanaged packages lack security and dependency ","version":"Next","tagName":"h3"},{"title":"Fundamentals of Deployment in Salesforce","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment","content":"","keywords":"","version":"Next"},{"title":"Difference Between Release and Deployment​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#difference-between-release-and-deployment","content":"   Release is the process of officially announcing and providing a new software version to end users. A release includes not only deployment but also user communication, documentation updates, marketing efforts, and support. It marks the point when a new version becomes available to the broader audience, and users can start using it.  Release management is discussed in a separate section of the portal  Deployment is the process of delivering changes to the environment. At this point, the code becomes available for use, but not necessarily to all users. Access to deployed solutions is managed within the release process.  Thus, deployment is the technical stage of updating a solution in the environment, but it doesn’t always mean it’s available to end users. A release is a broader process that includes deployment and other activities related to the new version’s launch for users.  Understanding the distinction between release and deployment is important as it allows for better planning and risk management. Releases require detailed planning and coordination, while deployment can be a more routine and regular process. Confusing these concepts may hinder the proper organization of the change process and increase business risks.  ","version":"Next","tagName":"h2"},{"title":"Sources of Truth for Deployment in Salesforce​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#sources-of-truth-for-deployment-in-salesforce","content":"   When deploying changes in Salesforce, there are two main approaches to selecting the Source of Truth:  Git as the source of truth — this is the most advanced and recommended approach for teams wanting to implement CI/CD processes. All changes are committed to Git, which is used for deployment.Salesforce Org as the source of truth — this is the traditional approach where deployment is done directly between environments without using Git, which may be convenient for smaller projects.  ","version":"Next","tagName":"h2"},{"title":"1. Git as the Source of Truth​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#1-git-as-the-source-of-truth","content":" Using Git as the primary source of truth is an approach that is becoming increasingly popular, especially in teams implementing CI/CD processes. All changes, whether code or metadata, are stored in a Git repository, and deployment is based on this data.  Git enables tracking changes in code and configurations, managing versions, and facilitating collaborative work among multiple developers on a single project. In the context of Salesforce, using Git helps organize the deployment and release processes and maintain a history of changes.  Git management is discussed in a separate section of the portal  Advantages:  Versioning: Ability to track every change, use branches for new features, and revert to previous versions.Automation: Easily integrates with CI/CD tools for automatic deployment, testing, and releases.Quality Control: Code reviews during repository merging help ensure that only vetted changes are deployed to target environments.Change Control: Integration of Git with task management systems helps control changes and manage releases.Simplified Rollback: If a deployment fails, reverting to a previous version is quick.Collaboration: Multiple developers can work on a single project without risking data loss.  Tools:  Salesforce CLI (SFDX): For working with Salesforce metadata and managing the deployment process through Git.CI/CD Systems: For example, Jenkins, GitHub Actions, and GitLab CI for automating deployments.Salesforce-Specific Tools: Salesforce DevOps Center, Gearset, Copado, etc., which provide user-friendly interfaces for Git interaction, branch management, and CI/CD setup. These tools often offer additional features like backups, quality gates, and testing.  ","version":"Next","tagName":"h3"},{"title":"2. Salesforce Org as the Source of Truth​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#2-salesforce-org-as-the-source-of-truth","content":" Before the widespread adoption of DevOps practices and Git, the primary approach was to use the Salesforce environment (Org) as the source of truth. This is where changes are made directly in one environment and then deployed to other environments (including Production).  Advantages:  Simplicity: Suitable for small teams and administrators who often use a no-code approach and don’t need complex change management processes.Immediate Testing: Changes can be tested in the same environment where they were made.  Disadvantages:  Lack of Versioning: Tracking changes is not as efficient as with Git.Automation Challenges: Automating deployments and testing requires more effort.Limited Change Control: Lack of integration between changes in environments and task management systems makes release management a challenge.  Tools:  Change Sets: A Salesforce tool for transferring changes between environments.Salesforce CLI and Ant Migration Tool: Used to extract metadata from one org and deploy it to another. These tools allow for direct deployment without using Git.  ","version":"Next","tagName":"h3"},{"title":"The Role of Manual Changes​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#the-role-of-manual-changes","content":" Manual changes may be necessary in situations where automation is impossible, too complex, or impractical. For example, manual steps are often needed for activating specific Flow versions, creating or modifying custom labels, executing Apex scripts, activating/deactivating bots, or making data changes. Here you can find possible deployment options for different metadata.  ","version":"Next","tagName":"h2"},{"title":"Risks and Best Practices to Minimize Manual Interventions​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#risks-and-best-practices-to-minimize-manual-interventions","content":" The primary risk of manual changes is the potential for errors. To minimize these risks:  Document all manual changes.Manual steps should be clear and detailed.A project policy for recording manual steps should be developed and implemented.Automate manual steps whenever possible.Perform testing before changes are implemented.  ","version":"Next","tagName":"h3"},{"title":"Tools for Documenting and Tracking Manual Changes​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#tools-for-documenting-and-tracking-manual-changes","content":" For documenting and tracking manual changes, you can use tools like Jira, Confluence, or simple text files in the repository. It is important that the entire team has access to these documents, can view the history of changes, and adheres to consistent rules for documenting manual steps.  ","version":"Next","tagName":"h3"},{"title":"Data Delivery Methods​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#data-delivery-methods","content":" In Salesforce, there are two main ways to transfer changes based on the source of truth. One method uses the environment as the source of truth, while the other uses a version control system (Git).  ","version":"Next","tagName":"h2"},{"title":"Source of Truth: Environment​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#source-of-truth-environment","content":" Managed Package​  Features: A Managed Package is a method for distributing and delivering applications and changes in the form of a managed package that can be installed in other Salesforce organizations. Managed packages protect the developer’s source code and data from changes, making them ideal for third-party developers and ISVs (Independent Software Vendors) who want to distribute their products on the AppExchange platform.  Pros and Cons:  Pros: Ensures version control, making it easy to release new versions and updates without user intervention.Supports automatic updates for clients, simplifying the distribution of changes.Protects code and data from unauthorized access. Cons: Less flexible for customization in client organizations, as code and settings changes are restricted.Managing individual components can be challenging due to the need for strict version control.  Key Commands and Documentation: Key commands and instructions for creating and managing Managed Packages can be found in Salesforce documentation.  Unmanaged Package​  Features: Unmanaged Packages allow for distributing changes in a package that can be installed in other Salesforce organizations, but unlike a managed package, components can be changed after installation. This is suitable for sharing templates, demo solutions, or internal use where changes and settings can be tailored to client needs.  Pros and Cons:  Pros: Allows for component changes after installation, providing high flexibility for users.Suitable for distributing learning materials, templates, and demo solutions.Simple to create and install, without strict version control requirements. Cons: No version control, making it impossible to manage updates or patches centrally.Open code and components can be modified or deleted in the client organization.No automatic updates, making it difficult to manage further changes.  Key Commands and Documentation: More information about working with Unmanaged Packages can be found in Salesforce documentation.  Change Set​  Features: Change Set is a built-in Salesforce tool for transferring metadata between related orgs (e.g., from sandbox to production). Change Set provides a user-friendly graphical interface for selecting and sending components. However, Change Set does not support versioning of metadata, meaning that once deployed, components do not retain information about previous versions.  Pros and Cons:  Pros: Easy to use: does not require programming skills.Allows transferring selected components through the standard Salesforce interface.Supports transfers between related organizations (e.g., sandbox -&gt; production).Easy to track the status of a change set (sent, under review, deployed). Cons: Lack of metadata versioning: once deployed, components cannot be rolled back.Limited to related organizations: cannot send changes to unrelated orgs or other Salesforce instances.Does not support integration with deployment automation tools (e.g., CI/CD).Does not support transferring all types of metadata, which may require the use of other tools.Limited flexibility in managing component dependencies.  Key Commands and Documentation: The description of working with Change Sets can be found in official documentation.  ","version":"Next","tagName":"h3"},{"title":"Source of Truth: Git​","type":1,"pageTitle":"Fundamentals of Deployment in Salesforce","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_01_Fundamentals_of_Deployment#source-of-truth-git","content":" Unlocked Package​  Features: Unlocked Packages were introduced as part of the new Salesforce DX architecture. Using Unlocked Packages allows for more flexible change management compared to Unmanaged Packages. The main purpose of Unlocked Packages is to manage components during development and deliver changes with a more controlled structure, including support for CI/CD processes.  Pros and Cons:  Pros: Easier to update and manage compared to Unmanaged Packages.Supports versioning and integration with CI/CD processes.Suitable for internal use and development, especially for creating modular packages. Cons: More complex to set up and manage for beginners compared to Unmanaged Packages.Does not protect code like a Managed Package.  Key Commands and Documentation: Salesforce DX Developer Guide Unlocked Packages  Metadata API Project (Metadata Format)​  Features: The Metadata API Project (or Metadata Format) is the format used when working with Salesforce metadata through the Salesforce Metadata API. This approach allows exporting, modifying, and deploying metadata outside Salesforce in the form of files and folders. The Metadata API is used to transfer and manage metadata between Salesforce orgs or integrate with external systems through automation tools (e.g., CI/CD). This format is particularly useful for more complex development scenarios when managing large projects and using version control systems like Git.  Pros and Cons:  Pros: Versioning support: easily integrates with version control systems (e.g., Git), allowing you to track and manage changes.Supports many types of metadata not available through other methods (e.g., Change Set).Ideal for complex projects, teamwork, and CI/CD integration.Allows automating change transfer using scripts or specialized tools (e.g., Jenkins or GitLab CI).Full control over exporting and deploying metadata. Cons: More complex to set up and use compared to Change Sets and requires knowledge of working with APIs and external tools.Deployment through the Metadata API can be slow, especially for large metadata sets.Labor-intensive for small changes, as it requires careful control of component dependencies.Deployment errors can be difficult to diagnose, especially in complex projects.  Key Commands and Documentation: Description of working with Metadata API is available in Salesforce documentation.  Salesforce DX Project (Source Format)​  Features: Salesforce DX Project (Source Format) is a format for organizing source code and metadata, introduced with Salesforce DX (Developer Experience). Unlike Metadata API Format, Source Format organizes metadata more modularly and structurally. This format is designed for easy version control integration, modular development support, and improved teamwork. It is especially useful for managing metadata within CI/CD processes.  Pros and Cons:  Pros: Supports modular development: source code and metadata are broken into smaller parts, making them easier to manage.Full integration with version control systems (e.g., Git), improving change tracking and collaboration.Supports CI/CD processes and deployment automation.Simplifies working with packages, allowing easier management of component dependencies and versions.Allows working with a local version of the project, making development and testing more flexible.Easily converts to Metadata Format for subsequent deployment. Cons: Requires a higher technical skill level for setup and use compared to traditional tools like Change Set.Can be complex for small projects where CI/CD or team collaboration is unnecessary.Requires using Salesforce CLI and additional tools, which may be unfamiliar to developers previously using only Salesforce’s standard interfaces.  Key Commands and Documentation: Detailed information about Salesforce DX can be found in Salesforce DX documentation. ","version":"Next","tagName":"h3"},{"title":"Deploy Profile and Permission Set","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_100_Metadata_Features/02_03_100_03_Profiles_n_PermissionSet","content":"Deploy Profile and Permission Set","keywords":"","version":"Next"},{"title":"Run Tests for Deployment","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment","content":"","keywords":"","version":"Next"},{"title":"Running All Tests — RunLocalTests​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#running-all-tests--runlocaltests","content":" Using the RunLocalTests parameter during deployment initiates all local tests written in the project (excluding tests in managed packages or those dependent on external packages). If tests are deployed within a package, the version from the current deployment is used. This approach ensures a high degree of code quality and system stability verification before introducing changes to the target environment.  ","version":"Next","tagName":"h2"},{"title":"Technical Implementation of Tests​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#technical-implementation-of-tests","content":" The technical implementation of tests is independent of the chosen deployment type. Whether you select deployment by directory, specific files, or package.xml, the approach remains the same.  To run all local tests (including those in the deployment), you need to specify the following option: --test-level RunLocalTests  For example: $ sf project deploy start --manifest path/to/package.xml --target-org my-org --test-level RunLocalTests  ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#advantages","content":" Maximum Confidence in Code Quality: Running all local tests ensures that even non-obvious errors unrelated to the current changes are detected, helping to prevent issues that might otherwise go unnoticed with selective testing.System Integrity: Running all tests before deployment confirms that new changes do not break existing functionality, supporting system integrity across all modules.Standardization of the Testing Process: Regularly running all tests maintains high development standards and standardizes code review processes, which is particularly beneficial for large teams with varied responsibilities.Detection of Hidden Dependencies: Running all tests highlights dependencies between modules and objects that might be affected by changes, reducing the risk of unexpected failures in the production environment.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#disadvantages","content":" Increased Deployment Time: Running all tests can take considerable time, especially on large projects with many classes, lengthening the delivery process, which is critical when frequent deployments or urgent releases, such as HotFixes, are required.Increased CI/CD Infrastructure Load: Running all tests requires additional computational resources, increasing the load on the CI/CD infrastructure and potentially reducing performance for other tasks.Redundant Testing for Minor Changes: For small or localized changes, running all tests may be excessive, as many tests are unrelated to the changes, making the deployment process less efficient.Risk of False Positives: With a large volume of tests, the likelihood of false positives increases, requiring additional time for checking and analyzing results.  ","version":"Next","tagName":"h3"},{"title":"Running all tests with the RunLocalTests parameter is appropriate in the following scenarios:​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#running-all-tests-with-the-runlocaltests-parameter-is-appropriate-in-the-following-scenarios","content":" Significant Changes or Deployment to Production: For critical releases and deployments to production, running all tests helps ensure stability and code quality.Regression Before Major Releases: Full testing is beneficial before large releases to ensure that all aspects of the system work correctly after substantial changes.Stable CI/CD Infrastructure: If the team has a well-organized CI/CD infrastructure with sufficient resources, regularly running all tests helps maintain a high level of quality.Projects with High Component Dependency: In large projects with closely interconnected components and complex dependencies, running all tests helps identify potential issues early on.  ","version":"Next","tagName":"h3"},{"title":"Running Specific Tests — RunSpecifiedTests​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#running-specific-tests--runspecifiedtests","content":" Using the RunSpecifiedTests parameter during deployment executes only specified tests, enabling the team to run only those necessary to verify specific changes. This method is particularly useful when rapid changes need to be deployed without involving the entire test suite and is preferred for optimizing CI/CD processes in projects with frequent, small updates.  As an option for storing the test database to run specified tests, it’s possible to use a test coverage matrix.  ","version":"Next","tagName":"h2"},{"title":"Technical Implementation of RunSpecifiedTests​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#technical-implementation-of-runspecifiedtests","content":" Similar to RunLocalTests, the technical implementation of RunSpecifiedTests does not depend on the selected deployment type. Whether you choose deployment by directory, specific files, or package.xml, the approach remains the same.  To run specified tests (including those in the deployment), you need to set the option: --test-level RunSpecifiedTests and specify the tests using the --tests flag.  For example: $ sf project deploy start --manifest path/to/package.xml --target-org my-org --test-level RunSpecifiedTests --tests MyTest1 --tests MyTest2 --tests MyTest3 Note: Only the test names should be specified—omit the .cls extension.  ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#advantages-1","content":" Time Savings and Faster Deployment: Running only necessary tests significantly reduces deployment time, especially in large projects with numerous tests where a full run could be too lengthy.Reduced CI/CD Infrastructure Load: The RunSpecifiedTests parameter reduces the load on CI/CD infrastructure as it requires fewer resources than running all tests.Testing Flexibility: The ability to select specific tests gives the team flexible control, enabling them to run only critical tests or those directly related to changes, which helps detect potential issues faster.Optimization for Urgent Fixes and Frequent Releases: Deploying with only the necessary tests suits situations where quick fixes (such as HotFixes) are needed, avoiding the delay of running all tests and thus minimizing downtime and speeding up release.Quality Control: This method fits well within quality control systems and automated CI/CD processes. For example, when a class is changed in a pull request to the integration branch, only related tests can be automatically triggered, allowing issues to be detected early.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#disadvantages-1","content":" Risk of Missing Dependent Tests: If modified components rely on other parts of the system, running only specific tests might not cover all possible scenarios, increasing the chance of errors that a full test run could reveal.Need to Maintain Test Lists: Maintaining up-to-date test lists is necessary, particularly if the project is actively evolving. This may increase the team’s workload, as they must carefully select tests for each deployment and maintain systems of control, like a test coverage matrix.Risk of a False Sense of Security: Running only selected tests may lead the team to underestimate the potential impact of changes on other parts of the system, creating a risk of unnoticed errors in other modules.  ","version":"Next","tagName":"h3"},{"title":"Running tests with the RunSpecifiedTests parameter is appropriate in the following scenarios:​","type":1,"pageTitle":"Run Tests for Deployment","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_04_Run_Tests_for_Deployment#running-tests-with-the-runspecifiedtests-parameter-is-appropriate-in-the-following-scenarios","content":" Frequent and Small Changes: If the team makes frequent but minor updates, running only necessary tests helps accelerate deployment and reduce the load on CI/CD infrastructure.HotFixes and Urgent Updates: In cases where a quick release is needed to fix an error, running only critical tests enables fast deployment, minimizing the time needed to deliver fixes.Testing of Independent Components: When changes are isolated to specific functionality, running only relevant tests allows focus on the needed areas without requiring all tests to be executed. ","version":"Next","tagName":"h3"},{"title":"Deploy Custom Object","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_100_Metadata_Features/02_03_100_04_Custom_Object","content":"Deploy Custom Object","keywords":"","version":"Next"},{"title":"Fundamentals of Change Management","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_04_Change/02_04_01_Fundamentals_of_Change_Management","content":"Fundamentals of Change Management","keywords":"","version":"Next"},{"title":"How to Deploy Custom Labels","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_100_Metadata_Features/02_03_100_02_Custom_Label","content":"How to Deploy Custom Labels","keywords":"","version":"Next"},{"title":"Unlocked Packages","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages","content":"","keywords":"","version":"Next"},{"title":"Benefits of Using Unlocked Packages​","type":1,"pageTitle":"Unlocked Packages","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages#benefits-of-using-unlocked-packages","content":" Unlocked Packages have become a popular solution for internal development for several reasons:  Flexibility and Modularity: Internal development teams often prefer Unlocked Packages because this approach allows for dividing code into independent modules, making management easier and improving code structure. This is especially helpful for large projects with many interdependent components.CI/CD Support and Automation: Unlocked Packages integrate well with CI/CD pipelines, simplifying automation, testing, and deployment. For teams aiming to implement DevOps and automate processes, Unlocked Packages provide the tools and capabilities to improve efficiency.Versioning and Change Control: The ability to manage package versions and roll back changes without impacting other system parts is a major advantage for internal development. This is particularly important for companies with strict requirements for update control and version consistency.Versatility for Multi-Product Organizations: Unlocked Packages are convenient for companies with multiple production environments, such as those in different regions or serving various business units. The same package can be installed in multiple production environments, supporting consistency and simplifying version management, which reduces development and maintenance costs.  ","version":"Next","tagName":"h2"},{"title":"Ideal Projects and Use Cases​","type":1,"pageTitle":"Unlocked Packages","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages#ideal-projects-and-use-cases","content":" Unlocked Packages are most effective in the following scenarios:  Large and Complex Projects: In projects with many components and complex dependencies, Unlocked Packages enable codebase structuring. Components can be split into modules, each of which is deployed and updated independently.Companies with Multiple Production Environments: Unlocked Packages are ideal for companies with multiple production environments (e.g., for different regions or business units). The same version of a package can be installed in multiple environments, simplifying change propagation and ensuring consistency.Projects with Regular Updates: If a project is evolving rapidly and requires frequent updates, Unlocked Packages simplify change management by allowing individual packages to be updated without redeploying the entire system.Projects with High Levels of Automation and Quality Control: For projects with active CI/CD practices, Unlocked Packages enable automated pipelines that speed up testing and deployment of changes.  ","version":"Next","tagName":"h2"},{"title":"Versioning and Version Management​","type":1,"pageTitle":"Unlocked Packages","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages#versioning-and-version-management","content":" Versioning is a key feature of Unlocked Packages. Each build creates a unique package version, which allows for:  Tracking changes and dependencies between components.Performing rollbacks to a previous version when necessary.Managing functionality and dependencies at the version level, making it easier to introduce new features and fix bugs.  Versioning makes Unlocked Packages particularly useful for projects with frequent changes, where version control and the ability to respond to changes quickly are crucial. Each component and its changes are easily integrated into the main development branch, reducing the risk of deployment errors.  ","version":"Next","tagName":"h2"},{"title":"CI/CD Automation​","type":1,"pageTitle":"Unlocked Packages","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages#cicd-automation","content":" Automation is one of the key advantages of using Unlocked Packages. They integrate easily into CI/CD processes, supporting the following stages:  Package Build: A new Unlocked Package version is created during the build stage, which can then be tested and stored in a version control system.Automated Testing and Quality Checks: Unlocked Packages simplify the setup of automatic test launches. When integrated with CI/CD, tests run only for changed components, speeding up verification.Multi-Stage Deployment: Unlocked Packages support flexible pipelines, allowing changes to be deployed across different environments (dev, test, stage) before final production.Version Control and Rollback: With built-in version support, CI/CD pipelines can easily roll back to previous versions if the new version causes errors or issues.  Automation allows the team to deploy and test changes without impacting other system components, significantly reducing time and simplifying application maintenance.  ","version":"Next","tagName":"h2"},{"title":"The Role of DevHub​","type":1,"pageTitle":"Unlocked Packages","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages#the-role-of-devhub","content":" DevHub is a required component for creating and managing Unlocked Packages. DevHub provides the following features:  Organizing the Development Workflow: DevHub manages the creation, updating, and deletion of Unlocked Packages and controls resource allocation across different development stages.Scratch Org Creation: DevHub simplifies the creation of temporary Scratch Orgs for developing and testing Unlocked Packages, allowing features to be tested independently of the main system.Dependency Management and Project Structuring: DevHub helps manage dependencies between packages, which is especially important for large projects. DevHub also simplifies the integration of new components into CI/CD pipelines.  DevHub is essential for working with Unlocked Packages, as creating and managing packages in Salesforce DX is impossible without it. DevHub provides a unified interface for administration, version management, and package state tracking, enhancing collaboration among developers, DevOps engineers, and administrators. However, DevHub should be chosen carefully, as changing DevHub requires contacting Salesforce support and can complicate package management.  ","version":"Next","tagName":"h2"},{"title":"Key Commands for Working with Unlocked Packages​","type":1,"pageTitle":"Unlocked Packages","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages#key-commands-for-working-with-unlocked-packages","content":" Creating a Package Version: sf package version create --package &lt;&quot;Your Package Alias&quot;&gt; --installation-key &lt;password&gt; --target-dev-hub &lt;DevHub alias&gt; --code-coverage Note: You can create a version without --code-coverage, but such a version cannot be promoted.  Promoting a Package Version: sf package version promote --package &lt;ID&gt; --target-dev-hub &lt;devhub@example.com&gt; Note: Only a promoted version can be installed in production environments, including those not linked to DevHub.  Installing a Package with Settings: sf package install --package &lt;ID&gt; --target-org &lt;alias&gt; --apex-compile &lt;all|package&gt; --upgrade-type &lt;DeprecateOnly|Mixed|Delete&gt; --security-type &lt;AllUsers|AdminsOnly&gt; --installation-key &lt;password&gt;   The --apex-compile parameter is typically set to package, though the default is all.The --upgrade-type parameter is often used with the Mixed value, which is also the default.The --security-type parameter is configured according to requirements, with the default being AdminsOnly.  You can also install the package manually by using a link in the format: &lt;target org link&gt;/packaging/installPackage.apexp?p0=&lt;package ID&gt;   However, you will need to manually enter the password and specify the installation parameters:  ","version":"Next","tagName":"h2"},{"title":"Notes​","type":1,"pageTitle":"Unlocked Packages","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_08_Unlocked_Packages#notes","content":" Although this package type has many advantages, it’s important to consider its limitations, which are outlined in the main article on packages - link.  Official Documentation: Salesforce Developers ","version":"Next","tagName":"h2"},{"title":"Deployment Options for Metadata","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment","content":"","keywords":"","version":"Next"},{"title":"Full Metadata Deployment​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#full-metadata-deployment","content":" This method is typical for projects with a less developed CI/CD culture and is often found in smaller projects where resources or opportunities to engage CI/CD specialists are limited. A full deployment takes more time as it involves deploying all metadata and running all tests.  Large projects generally favor more flexible deployment methods where only the modified metadata is deployed, saving resources and shortening delivery timelines while maintaining reliability and consistency.  ","version":"Next","tagName":"h2"},{"title":"Technical Implementation​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#technical-implementation","content":" The implementation is carried out using basic commands: $ sf project deploy start --source-dir force-app --target-org my-org where force-app can contain all project files.  Alternatively, deployment can be performed using: $ sf project deploy start --manifest path/to/package.xml --target-org my-org In this case, the package.xml file must specify all project metadata.  ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#advantages","content":" Simplified Deployment Process: Full deployment from a single directory allows for easy automation, as all metadata objects are gathered in one place, reducing the need for complex configurations for selective deployment.Environment Integrity: Deploying all metadata at once reduces the risk of incomplete deployment. The entire structure and dependencies between components are deployed simultaneously, minimizing the likelihood of errors.Version Stability: Full deployment ensures that changes made by developers are synchronized, preventing conflicts. This is especially crucial for large teams where uncoordinated configuration changes can lead to version incompatibilities.Simplified Dependency Management: With full deployment, there is no need to track dependencies, as all objects are deployed together, reducing the risk of missing required components (such as triggers requiring Apex classes).Minimal Configuration for Selective Deployment: Deploying from force-app/main/default removes the need for additional setup for deploying individual files, simplifying CI/CD configuration.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#disadvantages","content":" Deployment of Unnecessary Changes: The project may contain components that do not require updates. Full deployment may include them, leading to unintended changes and making rollbacks or conflict resolution with other developers more complex.Increased Deployment Time: Full deployment takes longer than selective deployment of modified components, which is particularly critical for large projects where every additional operation slows the process.Potential Environmental Conflicts: Deploying all metadata, especially with varying configurations (e.g., environment variables), can create conflicts in the target environment.Risk of Overwriting Custom Settings: Full deployment can inadvertently overwrite configurations manually set in the target environment. For instance, production profile changes might be reset. This risk can be mitigated by configuring the forceignore file.Version Control Challenges: Full deployment makes it harder to track changes in code and metadata. Without strict version control, issues with rollback and restoration may arise.CI/CD Process Inefficiency: Full deployment requires CI/CD to process all metadata, even if only one component has changed, reducing efficiency and increasing testing load.  ","version":"Next","tagName":"h3"},{"title":"Full deployment may be justified in the following cases:​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#full-deployment-may-be-justified-in-the-following-cases","content":" Small projects or projects with minimal metadata, where deployment time is not critical.Early development stages when the system structure is still unstable and most metadata is subject to change.Projects requiring complete environment consistency, where any deviation from the full version may cause errors.  ","version":"Next","tagName":"h3"},{"title":"Partial Metadata Deployment (Delta Deployment)​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#partial-metadata-deployment-delta-deployment","content":" Delta deployment is a method in which only modified metadata is updated, leaving the rest of the structure untouched. This approach is often used in projects with mature CI/CD processes, where minimizing deployment time and reducing the risks associated with accidental changes or overwriting settings is essential. While delta deployment requires more complex setup, its advantages make it preferable for large projects with active development and robust version control.  ","version":"Next","tagName":"h2"},{"title":"Technical Implementation​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#technical-implementation-1","content":" The command for deploying only specific parts of metadata is similar to deploying the entire metadata set. However, in this case, you need to specify the directory or individual metadata components that you want to deploy.  For example: $ sf project deploy start --source-dir force-app/main/default/classes/MyClass.cls --source-dir force-app/main/default/flows/MyFlow.flow-meta.xml --source-dir force-app/main/default/permissionsets/My.permissionset-meta.xml --target-org my-org  Alternatively, you can use deployment with package.xml: $ sf project deploy start --manifest path/to/package.xml --target-org my-org In this case, however, your package should include only the modified metadata. Automation tools can be used to generate such specific packages.  ","version":"Next","tagName":"h3"},{"title":"Advantages​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#advantages-1","content":" Time and Resource Savings: Delta deployment reduces deployment time by updating only modified metadata, which is crucial for large projects where full deployment can be time-consuming.Reduced Risk of Overwriting Settings: Delta deployment minimizes the chance of accidental changes to user settings in the target environment, as only modified components are updated.Flexibility and Modularity in CI/CD: Delta deployment supports flexible CI/CD pipelines, enabling deployment at the component level and allowing for staged deployment phases.Version Management Ease: Deploying only modified metadata simplifies tracking and managing changes in version control systems (such as Git), easing rollback and restoration of specific component versions.Testing Optimization: Reducing the deployment scope allows for testing only the modified components, lessening the load on the test environment and speeding up the CI/CD process.Improved Delivery Efficiency: Delta deployment at every stage of CI/CD accelerates the release of changes, especially on large projects.Enhanced Quality Control: Delta deployment enables detailed quality checks at various delivery stages, as only modified components are deployed.  ","version":"Next","tagName":"h3"},{"title":"Disadvantages​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#disadvantages-1","content":" Complex Configuration: Delta deployment requires careful configuration, including lists of modified components, dependency tracking, and testing setup for only the modified parts.Risk of Missing Dependencies: Changes in one component may necessitate updates to other components. With complex dependencies, there is a risk of overlooking them, potentially causing errors.Version Control System Requirements: Delta deployment requires a reliable version control system to accurately track and manage changes.Limited Applicability in Early Development Stages: During active development, when the project structure is unstable, delta deployment can complicate the process due to frequent updates across multiple components.Challenges in Testing Isolated Changes: Some tests may depend on components that have not been modified, requiring complex testing logic to maintain system integrity.  ","version":"Next","tagName":"h3"},{"title":"Delta deployment is suitable for the following situations:​","type":1,"pageTitle":"Deployment Options for Metadata","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_03_Metadata_Deployment#delta-deployment-is-suitable-for-the-following-situations","content":" Large Projects with Extensive Metadata: It helps significantly reduce load and speed up the release process.Projects with Frequent, Minor Changes: For projects with regular updates, delta deployment ensures efficient updates.Stable Architecture: If the system structure is stable and dependencies between components are well-understood, delta deployment minimizes risks.High Level of CI/CD Automation: Delta deployment is most effective in projects with advanced CI/CD automation, where automatic tracking and deployment of only modified components are possible. ","version":"Next","tagName":"h3"},{"title":"How to Deploy Custom Labels Translation","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_100_Metadata_Features/02_03_100_01_Custom_Labels_Translation copy","content":"How to Deploy Custom Labels Translation Find the file force-app/main/default/translations/&lt;language_code&gt;.translation-meta.xml.Create the file if it does not exist. You can find the language code in the ISO Language Code Table: Salesforce Developer Documentation. Retrieve the file using SFDX: sfdx force:source:retrieve -p &quot;force-app/main/default/translations/&lt;language_code&gt;.translation-meta.xml&quot; -u &lt;Alias&gt; Filter the retrieved data: You will receive a lot of extra data. Choose only what you need. Completion: Once the necessary data is filtered and adjusted, the translation is ready for deployment.","keywords":"","version":"Next"},{"title":"Dark Launches","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_04_Change/02_04_03_Dark_Launches","content":"Dark Launches","keywords":"","version":"Next"},{"title":"Blue Green","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_04_Change/02_04_04_Blue_Green","content":"Blue Green","keywords":"","version":"Next"},{"title":"Incremental Releases","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_04_Change/02_04_05_Incremental_Releases","content":"Incremental Releases","keywords":"","version":"Next"},{"title":"A/B Testing","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_04_Change/02_04_06_A_B_Testing","content":"A/B Testing","keywords":"","version":"Next"},{"title":"Metadata Backup","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_06_Environments/02_06_02_Metadata_Backup","content":"Metadata Backup","keywords":"","version":"Next"},{"title":"Phased Rollouts","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_04_Change/02_04_02_Phased_Rollouts","content":"Phased Rollouts","keywords":"","version":"Next"},{"title":"DevOps Maturity Matrix","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_07_Project/02_07_01_DevOps_Maturity_Matrix","content":"","keywords":"","version":"Next"},{"title":"What Is It?​","type":1,"pageTitle":"DevOps Maturity Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_07_Project/02_07_01_DevOps_Maturity_Matrix#what-is-it","content":" The DevOps Maturity Matrix is a framework that helps organizations assess their current state in the DevOps domain and develop a growth plan. This matrix typically includes several levels of maturity, ranging from initial stages (e.g., traditional development processes) to optimized stages(where DevOps is fully integrated into the company's culture and processes).  ","version":"Next","tagName":"h2"},{"title":"Why Is It Needed?​","type":1,"pageTitle":"DevOps Maturity Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_07_Project/02_07_01_DevOps_Maturity_Matrix#why-is-it-needed","content":" The DevOps Maturity Matrix is essential for:  Determining the current level: Assessing the organization's position in its DevOps transformation journey.Planning for Improvements: Creating a roadmap for improving processes, tools, and practices.Identifying Gaps: Identifying areas that require improvement or development.Improving Product Quality: Guaranteeing higher-quality and more rapid software releases.Motivating the Team: Offering a clear developmental path that encourages team progression.  ","version":"Next","tagName":"h2"},{"title":"How to Create It?​","type":1,"pageTitle":"DevOps Maturity Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_07_Project/02_07_01_DevOps_Maturity_Matrix#how-to-create-it","content":" Developing a DevOps Maturity Matrix involves:  Defining Target Parameters: Selection of key DevOps aspects, such as automation, culture, measurement, and collaboration.Setting Maturity Levels: Defining various maturity levels for each parameter, typically from 1 to 5.Developing Assessment Criteria: Establishing criteria for each level of maturity. Criteria should contain an explicit and complete description of acceptance criteria and what must be done. The benefit for the organization/project should be described.Including Examples and Recommendations: Adding practical examples and recommendations for achieving each level.Determining Dependencies: Indicating dependencies between different categories and levels.  The creation of the matrix requires the participation of representatives from all teams involved in the delivery processes, such as Developers, Scrum Masters, Product Owners, QA, and others. Forming a transformation team is advisable.  ","version":"Next","tagName":"h2"},{"title":"How Is It Maintained?​","type":1,"pageTitle":"DevOps Maturity Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_07_Project/02_07_01_DevOps_Maturity_Matrix#how-is-it-maintained","content":" Maintaining the DevOps Maturity Matrix includes:  Regular Assessment: Conducting periodic evaluations to ascertain the organization's current maturity level.Planning Improvements: Outlining and organizing initiatives to advance to higher levels, specifying time frames like quarters or months.Tracking Progress: Monitoring changes and improvements in DevOps processes and compiling a report for the specified time frames with an explanation of the final results, conclusions, and recommendations.Updating the Matrix: Regularly updating the matrix to reflect changes in the industry and within the organization or project.  The DevOps Maturity Matrix is a dynamic document that needs to constantly evolve to align with the organization's shifting objectives and conditions. It is a valuable tool for understanding and directing the evolution of DevOps practices in the company. ","version":"Next","tagName":"h2"},{"title":"Data Backup","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_06_Environments/02_06_03_Data_Backup","content":"Data Backup","keywords":"","version":"Next"},{"title":"Comparison of Tools","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_10_Third-party_Solutions/02_10_01_Comparison_of_Tools","content":"Comparison of Tools","keywords":"","version":"Next"},{"title":"COPADO","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_10_Third-party_Solutions/02_10_02_COPADO","content":"COPADO","keywords":"","version":"Next"},{"title":"Knowledge and Skills","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps","content":"","keywords":"","version":"Next"},{"title":"Skills Experience Knowledge​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#skills-experience-knowledge","content":" ","version":"Next","tagName":"h2"},{"title":"Must to Have Skills:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#must-to-have-skills","content":" Experience in troubleshooting, diagnosis, and problem solving.Experience with change management systems and processes. Experience with release management tools (GitLab/Jira/Copado/...).Experience with CI/CD tools (Gearset/Copado/Jenkins/GitLab CI/...).Expertise in working with DevOps issues and coordinating the phases of the SDLC.Experience in development (Python/Go/Bash/Apex)Experience in VCS (GIT)Experience in SFDX CLIThe ability to work with mdapi and dx projects, knowing their differences and features.The ability to work with unlocked packages.Understanding of lean manufacturing/TPS principlesKnowledge of agile approaches (scrum/kanban/SAFe) and their features with possible technical implementation (bringing to life)  ","version":"Next","tagName":"h3"},{"title":"Nice to Have Skills:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#nice-to-have-skills","content":" Experience with AWS, API, Azure, CI/CD pipelines, Visualforce, ANT.Experience in working in large environments with multiple work streams and vendors.Ability to write Apex and JavaScript code.Ability to prepare reports on Continuous Integration and release execution.Experience with AppExchange packages installation and configuration.Familiarity with the Heroku platform.  ","version":"Next","tagName":"h3"},{"title":"Special knowledge includes such soft skills as:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#special-knowledge-includes-such-soft-skills-as","content":" Responsibility and reliabilityComposure in critical and conflict situationsAbility to work with people, educate, and support them when necessary  ","version":"Next","tagName":"h3"},{"title":"Trailhead SF​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#trailheadsf","content":" Admin Beginner - linkUser Management - linkQuick Start: Salesforce DX - linkQuick Start: Visual Studio Code for Salesforce Development - linkData Security - linkBuild Apex Coding Skills - linkSecond-Generation Managed Packages - linkQuick Start: Unlocked Packages - link  ","version":"Next","tagName":"h2"},{"title":"Trailmix:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#trailmix","content":" Architect Journey: Development Lifecycle and Deployment - link  ","version":"Next","tagName":"h3"},{"title":"Certifications​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#certifications","content":" ","version":"Next","tagName":"h2"},{"title":"Confirming an understanding of the specifics of working with Salesforce:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#confirming-an-understanding-of-the-specifics-of-working-with-salesforce","content":" Platform Developer I - linkDevelopment Lifecycle and Deployment Architect - linkAdministrator - linkDevOps Launchpad (Salesforce DevOps Fundamentals Certificate, Salesforce DevOps Leadership Certificate, Salesforce Backup Certificate)- link  ","version":"Next","tagName":"h3"},{"title":"Understanding of processes:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#understanding-of-processes","content":" Agile Project and Delivery Management (ICAgile) - linkLeading SAFe - linkITIL 4 Foundation - link  ","version":"Next","tagName":"h3"},{"title":"Grades​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_01_Knowledge_and_Skills_DevOps#grades","content":" Grade\tResponsibility and EmploymentJunior\tHelps to resolve issues with the deployment of developer metadata. Supports environments and CI/CD processes. Can be involved in performing manual steps or building automation. There is support from a mentor or manager. Junior+\tCan independently resolve 80% of deployment issues (research and problem-solving skills). Good interaction with teams. There is support from a mentor or manager. Middle\tPrepares and conducts uncomplicated releases to production. Able to independently support CI/CD. Solves all emerging deployment problems for developers. Suggests improvements to delivery and monitoring processes. Good communication with stakeholders. There is support from a mentor or manager. Middle+\tConducts any deployments to production. Solves internal and cross-team problems. Builds complete delivery processes and partially end-to-end and discovery processes. There is support from a mentor or manager. Senior\tAble to adapt and propose the optimal solution for the delivery process depending on the conditions set and available resources. Can implement the necessary automation and adjust processes. Improves the end-to-end delivery of large or complex products. Lead\tOperates with metrics, understands the needs of the business and the specifics of projects, and can find optimal and balanced solutions. Works with groups of teams from their own direction and others. ","version":"Next","tagName":"h2"},{"title":"Environment Monitoring","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_06_Environments/02_06_01_Environment_Monitoring","content":"Environment Monitoring","keywords":"","version":"Next"},{"title":"The Role of a DevOps Specialist","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101","content":"","keywords":"","version":"Next"},{"title":"Why a DevOps Specialist is Needed​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#why-a-devops-specialist-is-needed","content":" Enhancing collaboration and communication between software development and IT operations.Automating and streamlining software development and deployment processes.Implementing continuous integration and continuous delivery (CI/CD) pipelines to improve delivery quality, efficiency and responsiveness.Creation/optimization and accountability for end-to-end processes  ","version":"Next","tagName":"h2"},{"title":"What a DevOps Specialist Does​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#what-a-devops-specialist-does","content":" The tasks of a DevOps Specialist are centered around building and maintaining the infrastructure and tools needed for rapid software development and deployment.  Automating Infrastructure  Continuous Integration and Continuous DeploymentMonitoring and Managing environments.  ","version":"Next","tagName":"h2"},{"title":"How a DevOps Specialist Works​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#how-a-devops-specialist-works","content":" To achieve their goals, a DevOps Specialist adopts a variety of roles and responsibilities, including system administrator, developer, security expert, manager, and coach.  ","version":"Next","tagName":"h2"},{"title":"The System Administrator​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#the-system-administrator","content":" As a System Administrator, they manage and optimize infrastructure, ensure system reliability and scalability, and work closely with IT to align with organizational goals.  ","version":"Next","tagName":"h3"},{"title":"The Developer​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#the-developer","content":" As a Developer, they write scripts to automate various processes, contribute to software development, and implement automation tools.  ","version":"Next","tagName":"h3"},{"title":"The Security Expert​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#the-security-expert","content":" As a Security Expert, they integrate security practices into the development process, ensuring that security is a priority from the start of software development to deployment.  ","version":"Next","tagName":"h3"},{"title":"The Manager​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#the-manager","content":" A DevOps specialist manages delivery processes, receiving feedback in the form of metrics and feedback from teams. The specialist modifies processes according to the conditions and tasks within the company. They are accountable to stakeholders.  ","version":"Next","tagName":"h3"},{"title":"The Coach​","type":1,"pageTitle":"The Role of a DevOps Specialist","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/index0101#the-coach","content":" This role involves training employees and supporting them. A DevOps specialist creates documentation describing processes and instructions for developers and other interested parties. ","version":"Next","tagName":"h3"},{"title":"Salesforce DevOps Center","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_10_Third-party_Solutions/02_10_04_Salesforce_DevOps_Center","content":"Salesforce DevOps Center","keywords":"","version":"Next"},{"title":"Knowledge and Skills","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager","content":"","keywords":"","version":"Next"},{"title":"Skills Experience Knowledge​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#skills-experience-knowledge","content":" ","version":"Next","tagName":"h2"},{"title":"Must-Have Skills:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#must-have-skills","content":" Proven experience in planning, executing, and monitoring Salesforce projects on time and within budget.Deep knowledge of Agile practices and Waterfall approach to project management.Deep understanding of the Salesforce platform, including its functionalities, configurations, and best practices.Understanding the different approaches to development and delivery and their pros and cons (DX, MDAPI, packages).Working knowledge of DevOps principles and tools (CI/CD pipelines, Git, SFDX) used in Salesforce deployments.Ability to manage and communicate effectively with stakeholders across various levels of the organization.Ability to identify, analyze, and resolve project issues proactively. Develop contingency plans to mitigate risks and ensure smooth project delivery.Experience and deep knowledge in metrics and best practices for their application, depending on the project's goals.  ","version":"Next","tagName":"h3"},{"title":"Nice-to-Have Skills:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#nice-to-have-skills","content":" Familiarity with project management and collaboration tools (e.g., Netsuite OpenAir) and CI/CD tools relevant to Salesforce deployments.Background in consulting, especially in Salesforce.com or other CRM/SaaS solutions, providing a broad perspective on different implementation strategies.Understanding of change management methodologies for implementing new Salesforce functionalities within organizations.Familiarity with integrating Salesforce with external APIs for data exchange.  ","version":"Next","tagName":"h3"},{"title":"Special Knowledge:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#special-knowledge","content":" Capability to mentor, coach, and develop junior team members, fostering a culture of continuous improvement and learning.Ability to prioritize tasks, manage multiple projects simultaneously, and meet deadlines effectively.Strong analytical skills to assess project data and make informed decisions.Ability to adapt to changing project requirements and work effectively in a fast-paced environment.  ","version":"Next","tagName":"h3"},{"title":"Trailhead SF​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#trailheadsf","content":" Admin Beginner - linkUser Management - linkQuick Start: Salesforce DX - linkData Security - linkSecond-Generation Managed Packages - linkQuick Start: Unlocked Packages - link  Trailmix:​  Architect Journey: Development Lifecycle and Deployment - link  ","version":"Next","tagName":"h2"},{"title":"Certifications​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#certifications","content":" ","version":"Next","tagName":"h2"},{"title":"Confirming an understanding of the specifics of working with Salesforce:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#confirming-an-understanding-of-the-specifics-of-working-with-salesforce","content":" Development Lifecycle and Deployment Architect - link  ","version":"Next","tagName":"h3"},{"title":"Understanding of processes:​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#understanding-of-processes","content":" Agile Project and Delivery Management (ICAgile) - linkLeading SAFe - linkITIL 4 Foundation - linkProject Management Professional (PMP) - linkAgile Delivery at Scale (ICAgile) - link  ","version":"Next","tagName":"h3"},{"title":"Grades​","type":1,"pageTitle":"Knowledge and Skills","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_01_Knowledge_and_Skills_Delivery_Manager#grades","content":" Grade\tResponsibility and EmploymentJunior\tAssists in managing smaller projects or components of larger projects under supervision. Focuses on learning the basics of agile project management, tools, and techniques. Participates in meetings and supports the communication flow between teams. Receives guidance from a mentor or manager. Junior+\tManages small to medium projects with minimal supervision. Begins to handle client communications and coordinates effectively with team members. Tracks project progress, analyzes basic metrics, and identifies areas for improvement. Can identify and solve basic project issues. Still receives support from a mentor or manager but shows initiative and problem-solving skills. Middle\tManages projects of moderate complexity, ensuring on-time and on-budget delivery. Demonstrates strong communication with clients and stakeholders. Able to solve most of the project-related problems independently. Contributes to process improvement and effectively manages project risks. Manages dependencies across teams. Middle+\tLeads the delivery of complex projects with multiple teams and dependencies. Leads project planning, scheduling, monitoring, and reporting activities. Works across teams to solve complex issues and improve project delivery processes. Begins to contribute strategically, offering insights for improvement across projects. Optimizes delivery processes to improve efficiency and quality. Builds end-to-end, delivery and discovery processes. Senior\tFully responsible for the delivery of large and complex projects. Develops and implements Delivery strategies aligned with overall business goals. Excels in stakeholder management, strategic planning, and risk management. Manages a portfolio of projects, ensuring optimal resource allocation and prioritization. Identifies opportunities for organizational-level improvements in the delivery process. Innovates and leads in the adoption of new methodologies or tools to improve delivery efficiency and quality. Acts as a mentor to less experienced Delivery Managers and contributes to the strategic planning of the department. Lead\tOversees multiple projects or a portfolio, setting strategic direction and ensuring alignment with organizational goals. Leads and develops a team of Delivery Managers, fostering a culture of continuous improvement and excellence. ","version":"Next","tagName":"h2"},{"title":"Gearset","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_10_Third-party_Solutions/02_10_03_Gearset","content":"Gearset","keywords":"","version":"Next"},{"title":"Test Coverage Matrix","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix","content":"","keywords":"","version":"Next"},{"title":"Why Do You Need a Test Coverage Matrix?​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#why-do-you-need-a-test-coverage-matrix","content":" Simplifying Test Coverage Analysis The matrix offers an easy way to identify which tests cover specific classes and evaluate their coverage levels. This is particularly important for large projects with extensive codebases, where manual analysis becomes overly time-consuming.Managing Dependencies and Testing Priorities The matrix helps efficiently manage relationships between tests and classes, allowing you to run only the necessary tests. This reduces testing time and is especially useful in scenarios requiring quick responses, such as deploying hotfixes.Historical Tracking and Diagnostics Storing information about the date of the last test run and coverage levels helps track the relevance of tests, identify outdated or irrelevant tests, and detect changes that have impacted coverage.Improving Coverage Data Quality The matrix compensates for the shortcomings of Salesforce’s built-in test coverage data by providing an independent and reliable source. This ensures accurate analysis and verification of data.Automating Code Quality Control The matrix supports automation of quality control processes, ensuring transparency in test coverage. This helps maintain development standards and speeds up the resolution of identified issues.Integration with DevOps and CI/CD Processes The matrix simplifies the integration of testing into CI/CD pipelines, optimizing the deployment and verification of changes. This makes processes more consistent and reliable.Accelerating Code Reviews and Audits The matrix facilitates the analysis of coverage for changes, helping reviewers and testers quickly verify code quality and identify gaps.Fostering a Culture of Test Improvement A transparent data structure in the matrix motivates teams to track testing progress. Increasing coverage percentages and clearly understanding the current state promote a culture of quality and collaboration.  ","version":"Next","tagName":"h2"},{"title":"Key Requirements for the Matrix​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#key-requirements-for-the-matrix","content":" Developer Usability The matrix should be intuitive and accessible to all development team members. It should provide information in an easy-to-use format (e.g., JSON, XML, or YAML) and integrate seamlessly into the team's workflows. The interface or file structure should minimize time spent working with the data.Automation-Friendly The matrix should easily integrate with automation tools like CI/CD pipelines or quality control systems. Its data format should be standardized and suitable for programmatic processing, enabling scenarios like automated report generation and coverage checks during deployment.Support for Multiple Test Classes Per Class In complex projects, a single class may be covered by multiple tests. The matrix should support specifying multiple test classes for one validated class to ensure transparency and meet project coverage requirements.Ability to Add Comments The matrix should allow for adding comments to classes, tests, or their relationships. These comments could include critical information for developers, such as the reason for insufficient coverage or specific testing details. Additionally, some comments can be used in automation logic, such as skipping specific classes in tests or providing processing instructions.Data Relevance The matrix should include information about the last update of coverage for each class. This helps teams analyze the relevance of data and take timely actions to update it, avoiding the use of outdated or irrelevant information.Principle of Necessity and Sufficiency The matrix should avoid redundancy by storing only necessary and sufficient information. This means including only those tests and classes that have actual relationships and are important for coverage analysis. Excessive detail or data duplication can complicate the use of the matrix and automation processes.  ","version":"Next","tagName":"h2"},{"title":"Example of a Test Coverage Matrix​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#example-of-a-test-coverage-matrix","content":" ","version":"Next","tagName":"h2"},{"title":"XML Example​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#xml-example","content":" &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;classes&gt; &lt;class&gt; &lt;testname&gt;MyClassTest.cls&lt;/testname&gt; &lt;coverage&gt;100.0%&lt;/coverage&gt; &lt;date&gt;2023_12_31&lt;/date&gt; &lt;classname&gt;MyClass.cls&lt;/classname&gt; &lt;description&gt;Specific dependencies&lt;/description&gt; &lt;/class&gt; &lt;class&gt; &lt;testname&gt;MyClass2Test.cls&lt;/testname&gt; &lt;coverage&gt;76.62%&lt;/coverage&gt; &lt;date&gt;2023_12_31&lt;/date&gt; &lt;classname&gt;MyClass2.cls&lt;/classname&gt; &lt;description&gt;Note on the class&lt;/description&gt; &lt;/class&gt; &lt;class&gt; &lt;testname&gt;MyClass1Test.cls&lt;/testname&gt; &lt;testname&gt;MyClass3Test.cls&lt;/testname&gt; &lt;coverage&gt;91.37%&lt;/coverage&gt; &lt;date&gt;2023_12_31&lt;/date&gt; &lt;classname&gt;MyClass3.cls&lt;/classname&gt; &lt;description&gt;Note on coverage&lt;/description&gt; &lt;/class&gt; &lt;/classes&gt;   ","version":"Next","tagName":"h3"},{"title":"JSON Example​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#json-example","content":" [ { &quot;testname&quot;: &quot;MyClassTest.cls&quot;, &quot;coverage&quot;: &quot;100.0%&quot;, &quot;date&quot;: &quot;2023_12_31&quot;, &quot;classname&quot;: &quot;MyClass.cls&quot;, &quot;description&quot;: &quot;Specific dependencies&quot; }, { &quot;testname&quot;: &quot;MyClass2Test.cls&quot;, &quot;coverage&quot;: &quot;76.62%&quot;, &quot;date&quot;: &quot;2023_12_31&quot;, &quot;classname&quot;: &quot;MyClass2.cls&quot;, &quot;description&quot;: &quot;Note on the class&quot; }, { &quot;testname&quot;: [ &quot;MyClass1Test.cls&quot;, &quot;MyClass3Test.cls&quot; ], &quot;coverage&quot;: &quot;91.37%&quot;, &quot;date&quot;: &quot;2023_12_31&quot;, &quot;classname&quot;: &quot;MyClass3.cls&quot;, &quot;description&quot;: &quot;Note on coverage&quot; } ]   ","version":"Next","tagName":"h3"},{"title":"YAML Example​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#yaml-example","content":" - testname: MyClassTest.cls coverage: &quot;100.0%&quot; date: 2023_12_31 classname: MyClass.cls description: Specific dependencies - testname: MyClass2Test.cls coverage: &quot;76.62%&quot; date: 2023_12_31 classname: MyClass2.cls description: Note on the class - testname: - MyClass1Test.cls - MyClass3Test.cls coverage: &quot;91.37%&quot; date: 2023_12_31 classname: MyClass3.cls description: Note on coverage   ","version":"Next","tagName":"h3"},{"title":"How to Retrieve Data for the Matrix​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#how-to-retrieve-data-for-the-matrix","content":" To build the test coverage matrix or analyze code coverage in Salesforce, SOQL queries can be used via the Tooling API. Below are methods to extract coverage data.  ","version":"Next","tagName":"h2"},{"title":"1. Overall Coverage for Each Class or Trigger​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#1-overall-coverage-for-each-class-or-trigger","content":" Use this query to retrieve aggregated code coverage for each class or trigger: SELECT ApexClassOrTrigger.Name, NumLinesUncovered, NumLinesCovered FROM ApexCodeCoverageAggregate   Fields in the Result:  ApexClassOrTrigger.Name: The name of the class or trigger.NumLinesUncovered: The number of uncovered lines.NumLinesCovered: The number of covered lines.  This query is suitable for high-level analysis of code coverage in a project.  ","version":"Next","tagName":"h3"},{"title":"2. Coverage by Test Method​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#2-coverage-by-test-method","content":" For a detailed analysis, including information about test methods, use the following query: SELECT ApexTestClass.Name, TestMethodName, ApexClassOrTrigger.Name, NumLinesUncovered, NumLinesCovered FROM ApexCodeCoverage Fields in the Result:  ApexTestClass.Name: Name of the test class.TestMethodName: Name of the test method.ApexClassOrTrigger.Name: Name of the class or trigger being tested.NumLinesUncovered: Number of uncovered lines.NumLinesCovered: Number of covered lines.  This query is ideal for building a detailed matrix that shows relationships between test methods and classes.  ","version":"Next","tagName":"h3"},{"title":"3. Validating Coverage via Tests​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#3-validating-coverage-via-tests","content":" To validate a class with specific tests, use the following command: sf project deploy validate --source-dir &lt;path to class&gt; --target-org &lt;target env&gt; --test-level RunSpecifiedTests --tests &lt;testname&gt; --wait 120 --json The command returns validation results in JSON format, including the number of lines covered and uncovered.  Alternatively, to retrieve results later: sf project deploy report --target-org &lt;target env&gt; --job-id &lt;job ID&gt; --json   This method provides accurate coverage data but requires automation for efficiency.  ","version":"Next","tagName":"h3"},{"title":"Ideal Project Profile for Using a Test Coverage Matrix​","type":1,"pageTitle":"Test Coverage Matrix","url":"/SFITDelivery-KnowledgeHub/docs/Management/02_03_Deployment/02_03_09_Test_Coverage_Matrix#ideal-project-profile-for-using-a-test-coverage-matrix","content":" A test coverage matrix is most beneficial in projects with high code quality standards, complex structures, and frequent changes. Characteristics of such projects include:  Large Projects with Extensive Codebases Necessary for projects with dozens or hundreds of classes, triggers, and tests where manual coverage analysis is impractical.Frequent Changes and Rapid Development Cycles Essential in agile or DevOps environments where changes are made daily or weekly.CI/CD and DevOps Integration The matrix fits seamlessly into automated CI/CD pipelines, accelerating deployment and minimizing risks from insufficient coverage.High Code Quality Standards Critical for projects with strict coverage requirements (e.g., 85-90%).Complex Dependency Structures Necessary for managing relationships between interdependent components.Large Development Teams Supports coordination in multi-branch development environments.Salesforce DX and Unlocked Packages Aids in managing coverage at the package level for modular projects.Multiple Production Environments Maintains consistency across regions or business units.Transparency and Auditing Requirements Provides a clear source of coverage data for compliance and reviews.Projects involving vendors Using a matrix simplifies tracking the quality of development and adherence to standards on the project. ","version":"Next","tagName":"h2"},{"title":"Antipatterns","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Useful materials/99_03_Antipatterns","content":"Antipatterns","keywords":"","version":"Next"},{"title":"DevOps: Books Videos Materials","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Useful materials/99_01_useful_materials","content":"DevOps: Books Videos Materials Books Mastering Salesforce DevOps - link The DevOps Handbook - link Pro Git (free) - link Video Introduction: The State of Salesforce DevOps - link Discover Salesforce, DevOps and Copado CI/CD automations - link Azure DevOps with Salesforce - link Trailhead SF You need to study the following Trails: Admin Beginner - link User Management - link Quick Start: Salesforce DX - link Quick Start: Visual Studio Code for Salesforce Development - link Package Development Model - link Unlocked Packages for Customers - link Data Security - link Build Apex Coding Skills - link Articles (here you will find many answers on salesforce) Salesforce Developers Blog - link","keywords":"","version":"Next"},{"title":"Onboarding","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_03_Onboarding","content":"","keywords":"","version":"Next"},{"title":"DevOps​","type":1,"pageTitle":"Onboarding","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_03_Onboarding#devops","content":" Week\tTasks\tResult1\tMeet the team, stakeholders, gather project artifacts\tThe specialist met the team, studied the composition and roles, gained access to repositories, environments, documentation, and CI/CD pipelines. Familiarized with key project metrics 2-4\tStudy existing CI/CD pipelines, tools, and processes\tUnderstanding of current infrastructure and processes, setup of work environment, participation in deployments 5-8\tParticipate in automation and process optimization\tImprovements made to pipelines, participation in code reviews, scripting for automation 9-12\tConduct testing and system monitoring\tImplementation of test scenarios, setup of monitoring, working with logs 13-16\tWork on security and backup\tIntegration of security practices, setup of data and metadata backup 17-24\tDocumentation and training of teams and staff\tUpdating and creating documentation, conducting training sessions for teams on DevOps practices 25-32\tParticipate in release planning\tPlanning and coordinating releases, improving release processes, setting up Git strategy, coordinating changes considering stakeholder interests and project reliability 33-40\tInfrastructure optimization and support\tOptimization of infrastructure, participation in SRE practices, improvement of system performance 41-48\tLead process improvement initiatives\tManaging projects for process improvement, working with metrics, reporting to management  ","version":"Next","tagName":"h3"},{"title":"Delivery Manager​","type":1,"pageTitle":"Onboarding","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_03_Onboarding#delivery-manager","content":" Week\tTasks\tResult1\tGet acquainted with the team, and gather key team work artifacts\tThe team met with the manager, defined areas of responsibility, gained access to boards, knowledge base, and environments. Familiarized with key performance indicators (KPIs) and project metrics 2-4\tStudy current projects and processes, meet with stakeholders\tUnderstanding of current projects, studying documentation, participating in meetings, getting to know stakeholders, understanding the goals and objectives of current projects, familiarizing with solution architecture 5-8\tParticipate in project planning and management\tParticipating in planning, task prioritization, and scheduling, resource management 9-12\tOptimize processes and implement Agile practices\tImplementing and improving Agile processes, coordinating teams, establishing communication between teams, ensuring synchronization of team efforts, conducting retrospectives 13-16\tManage risks and quality\tIdentifying and managing risks, conducting internal quality audits, developing audit checklists, implementing improvements 17-24\tCommunication and reporting\tRegular reports for stakeholders, conducting and moderating meetings with the team and clients, improving communications, collecting and analyzing feedback 25-32\tChange management and process adaptation, training the team on new processes, monitoring the effectiveness of changes\tImplementing process changes, adapting to new requirements, coordinating changes across teams, assessing the impact of changes on the project, developing an adaptation plan 33-40\tTeam development and mentoring\tTraining and developing the team, conducting training sessions, providing support and mentorship for new team members 41-48\tStrategic planning and process improvement\tParticipating in strategic planning, developing long-term project development strategies, analyzing market trends, implementing best practices, improving project management processes, optimizing business processes ","version":"Next","tagName":"h3"},{"title":"Delivery Manager and DevOps on a Salesforce Project","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/","content":"","keywords":"","version":"Next"},{"title":"Salesforce​","type":1,"pageTitle":"Delivery Manager and DevOps on a Salesforce Project","url":"/SFITDelivery-KnowledgeHub/docs/Roles/#salesforce","content":" Salesforce is a SaaS (Software as a Service) solution. It provides a comprehensive suite of cloud-based applications designed to help businesses manage customer relationships, sales, and marketing more efficiently. As a SaaS platform, Salesforce offers a scalable and flexible solution that can be accessed from anywhere with an internet connection, eliminating the need for local installation and maintenance. This model allows businesses of all sizes to utilize advanced technology and infrastructure without significant upfront investment. Salesforce's services are continuously updated, ensuring that users have access to the latest features and security enhancements.    ","version":"Next","tagName":"h2"},{"title":"Delivery Manager and DevOps Specialist​","type":1,"pageTitle":"Delivery Manager and DevOps on a Salesforce Project","url":"/SFITDelivery-KnowledgeHub/docs/Roles/#delivery-manager-and-devops-specialist","content":" Salesforce is a SaaS solution, and due to its nature, on smaller projects, the roles of Release Managers, DevOps specialists, or Delivery Managers may be merged to optimize resources and simplify processes. When an effective and resilient CI/CD infrastructure is established, combining these roles can lead to increased operational efficiency and project management effectiveness.  ","version":"Next","tagName":"h2"},{"title":"Key Advantages of Role Consolidation​","type":1,"pageTitle":"Delivery Manager and DevOps on a Salesforce Project","url":"/SFITDelivery-KnowledgeHub/docs/Roles/#key-advantages-of-role-consolidation","content":" Merging the roles of Delivery Manager and DevOps into a single position or department can bring significant benefits:  Resource Optimization: A single person overseeing both delivery and deployment processes can streamline communication and decision-making, reducing delays between teams.Enhanced Responsiveness: With one person responsible for end-to-end processes, quicker adaptations to changes in requirements or project scope can be achieved, improving agility.Integrated Management: Combining roles helps in aligning project delivery with technical processes, ensuring smoother handoffs and better alignment with business objectives.  Both roles focus on ensuring the efficiency, reliability, predictability, scalability, and flexibility of project delivery processes. They are able to assess which tools and methodologies best suit a project based on its size, goals, and level of maturity. A consolidated approach allows for restructuring and adjusting processes more effectively as the business grows or changes.  ","version":"Next","tagName":"h3"},{"title":"Potential Risks of Merging Roles​","type":1,"pageTitle":"Delivery Manager and DevOps on a Salesforce Project","url":"/SFITDelivery-KnowledgeHub/docs/Roles/#potential-risks-of-merging-roles","content":" However, despite the clear benefits, merging the Delivery Manager and DevOps roles also carries certain risks:  Overburdening Individuals: One person may struggle to balance the strategic and operational demands of both roles, leading to burnout or a drop in performance quality.Knowledge Gaps: While Delivery Managers are often skilled in project management, they may lack the deep technical expertise required for complex DevOps tasks, or vice versa. This can lead to inefficiencies or errors in critical areas.Conflicts in Priorities: Project management and technical implementation often have different priorities. Delivery Managers may focus on meeting deadlines and aligning with business goals, while DevOps emphasizes stability, scalability, and the quality of technical execution. Balancing these conflicting priorities can complicate decision-making, potentially leading to delays or suboptimal solutions.  In summary, merging the roles of Delivery Manager and DevOps Specialist can be a viable solution for small projects or organizations with robust CI/CD infrastructure. However, careful consideration of the potential risks is essential to avoid inefficiencies and ensure the long-term success of project delivery.  ","version":"Next","tagName":"h3"},{"title":"Service Delivery Manager vs Delivery Manager​","type":1,"pageTitle":"Delivery Manager and DevOps on a Salesforce Project","url":"/SFITDelivery-KnowledgeHub/docs/Roles/#service-delivery-manager-vs-delivery-manager","content":" The Service Delivery Manager differs from the Delivery Manager in that the Delivery Manager on the project is responsible for the successful completion and delivery of the project, managing the team and resources. The Service Delivery Manager focuses on managing the quality and timely delivery of IT services, interacting with clients, and maintaining SLAs (Service Level Agreements). Delivery Manager - focuses on the project. Service Delivery Manager - focuses on long-term service and customer relationships.  ","version":"Next","tagName":"h2"},{"title":"About This Section of the Hub​","type":1,"pageTitle":"Delivery Manager and DevOps on a Salesforce Project","url":"/SFITDelivery-KnowledgeHub/docs/Roles/#about-this-section-of-the-hub","content":" The description of roles is divided into separate sections:  Role: DevOps SpecialistRole: Delivery Manager  The Management section is combined to simplify navigation and so that each company and project can independently define the necessary areas of influence for specialists. ","version":"Next","tagName":"h2"},{"title":"Responsibility","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_01_DevOps/01_01_02_Responsibility_DevOps","content":"Responsibility info The higher level inherits the responsibilities of the previous levels. Responsibility levels are not fixed. Duties can change depending on the project and company. It's important to consider the individual skills and experience of specialists. Grade\tJunior\tJunior+\tMiddle\tMiddle+\tSenior\tLeadAutomation and optimisation of delivery\tEnsuring the operability of individual jobs. Building simple automations as assigned. Creating tests to check automations.\tSupporting the operability of the entire pipeline.\tImproving and adapting any automations and processes as assigned. Proposing own improvements based on the analysis of existing processes.\tDefining and fixing errors and shortcomings of delivery processes, based on coordination of changes (with Senior or Lead and/or stakeholders).\tPrioritizing tasks related to delivery.\tTask distribution and control over their execution. Responsibility for all processes related to delivery. Improving the reliability of processes (technical aspect)\tMonitoring the state and performance of individual systems and services. Participating in routine log analysis and alerts to assist in identifying problems. Performing routine testing tasks. Documenting test scenarios and results. Tracking and recording incidents.\tAutomation of routine testing and monitoring tasks. Configuring tools for tracking performance. Analyzing test data and logs. Identifying and eliminating simple technical problems.\tAnalyzing complex systemic problems and developing recommendations for improving reliability. Developing and implementing comprehensive automated solutions for proactive detection and elimination of potential bottlenecks and errors.\tDeveloping strategies for improving the overall architecture of the system in terms of reliability and scalability. Leading junior specialists in performing tasks related to reliability. Initiating and conducting technical reviews and system audits. Analyzing and optimizing system performance. Implementing tools for monitoring and incident management. Developing and implementing SRE practices.\tMaking key technical decisions aimed at increasing the resilience and reliability of critical systems. Developing policies and procedures that ensure a high level of availability and security. Participating in the planning of capital improvements to the infrastructure.\tLeading strategic planning and managing projects to improve reliability and efficiency of technical processes. Ensuring compliance with reliability standards at all stages of development and operation of systems. Enhancing project reliability (matrix/coverage/validation)\tParticipation in the preparation of test data and basic testing scenarios. Monitoring and documenting test results. Assisting in maintaining up-to-date project documentation, ensuring the accuracy of the test coverage matrix.\tDefining testing and validation problems. Finding causes and solving through appeals to leads or mentors.\tInitiating quality improvement processes based on the analysis of test results.\tCoordinating testing and validation processes between teams, managing resources and testing tools. Conducting project validation. Analyzing and optimizing test coverage. Implementing test data management tools. Developing and implementing a validation strategy.\tMaking strategic decisions regarding project testing and validation methodologies. Assessing and implementing new technologies and approaches to improve product reliability and quality. Developing quality policies and standards, managing quality risks on the project.\tResponsibility for overall project reliability. Defining and implementing a quality assurance strategy. Risk management and incident response. Interacting with all stakeholders, including interaction with other development projects. Building a backup system (metadata/data)\tPerforming routine tasks for backup data and metadata under the guidance of more experienced colleagues. Restoring metadata and data from backups.\tActively participating in the implementation and optimization of backup procedures. Responsible for regular backup execution according to the established schedule. Conducting simple data recovery operations to verify the integrity of backups. Monitoring the backup system.\tDeveloping backup scenarios. Defining backup policy. Optimizing the backup system. Analyzing and resolving problems with backups.\tManaging the infrastructure for backups, including selecting and configuring tools and services for data and metadata backup. Ensuring the security of backups. Restoring the system from a backup. Analyzing and improving the efficiency of data recovery.\tDeveloping and implementing a backup strategy. Assessing and implementing new backup technologies. Leading a team of backup specialists.\tResponsibility for the overall backup system. Ensuring the backup system complies with requirements. Risk management and incident response. Monitoring environments\tSetting up basic dashboards and alerts based on provided settings and templates. Supporting the verification and maintenance of monitoring system operability. Participating in routine monitoring of system resources, application performance, and core services. Recording and escalating incidents.\tAnalyzing monitoring data to identify trends and potential problems. Proposing solutions to improve performance.\tSetting up and optimizing monitoring systems. Leading initiatives to improve performance based on monitoring data and environment.\tImplementing a monitoring system. Ensuring the security of the monitoring system. Analyzing complex problems and developing solutions to eliminate system bottlenecks.\tDeveloping and implementing a monitoring strategy. Assessing and implementing new monitoring technologies. Making key decisions on monitoring architecture and alerting. Ensuring the integration of monitoring systems with other DevOps tools for continuous delivery and configuration management.\tResponsibility for the overall monitoring system. Leading strategic planning and development of monitoring and alerting systems at the organizational level. Ensuring the monitoring system complies with requirements. Risk management and incident response. Developing a git strategy\tStudying and applying basic Git commands in accordance with the current team strategy. Participating in updating project documentation, including manuals on using Git. Supporting the resolution of basic merge conflicts under the guidance of more experienced colleagues.\tSetting up local and remote repositories according to established rules. Participating in the development and implementation of templates for commit messages and code review processes. Assisting in training new team members on the Git strategy, name conventions, and project rules.\tOptimizing Git workflow. Automating Git processes. Leading junior specialists in resolving complex merging issues and using Git.\tImplementing GitOps practices. Ensuring the security of the Git repository. Planning and implementing a branching strategy and merge policies for projects. Organizing and conducting training sessions on advanced Git techniques for the team.\tMaking key decisions regarding version control tools and processes in the project. Developing a comprehensive Git strategy, including integration with CI/CD systems and other DevOps tools. Implementing new Git tools. Assessing the impact of the Git strategy and applied systems on project performance and security.\tResponsibility for the overall Git strategy. Developing security policies and code compliance requirements in the context of Git. Coordinating with development, testing, and operation teams to ensure effective integration and use of Git within DevOps practices. Risk management and incident response. Developing a release strategy\tParticipation in the preparation and execution of tasks related to releases under the guidance of more experienced colleagues. Assisting in updating release documentation and the knowledge base. Learning the basics of version management and release processes.\tAutomating routine tasks for release preparation. Tracking and reporting on the progress of tasks related to current releases.\tActively participating in release planning. Optimizing release strategy. Independently conducting releases. Developing and optimizing CI/CD processes according to project requirements. Assessing risks and managing issues related to releases.\tDeveloping and implementing a release management strategy tailored to the tasks and requirements of the project. Assessing changes using metrics. Coordinating between development, testing, and operation teams to ensure consistency and quality of releases.\tMaking key decisions on release strategy, including the selection of tools and methodologies, supporting change management decisions. Developing security policies and compliance requirements in the release process. Leading and training the team in best practices and release procedures.\tManaging and ensuring communication between stakeholders. Developing and implementing innovative approaches to delivery and release management for continuous process improvement. Developing and maintaining a culture of continuous improvement in the team and organization. Interaction with teams and responding to feedback\tParticipating in team meetings. Performing tasks assigned by the team. Collecting and transmitting feedback. Participating in the process of gathering requirements and suggestions for process improvement.\tActively collaborating with developers, testers, and business analysts to clarify tasks and determine priorities. Constructively responding to feedback. Participating in product quality improvement processes based on user feedback analysis. Proposing ideas and solutions.\tCoordinating interaction between different teams for efficient resolution of arising tasks and questions. Developing and implementing mechanisms for collecting and analyzing feedback from users and the team. Proposing and implementing process improvements based on received feedback.\tDeveloping and implementing a strategy for interaction with teams. Managing conflicts and ensuring effective communication between teams.\tMaking strategic decisions based on the analysis of feedback from teams and users. Defining long-term goals for team interaction and product improvement. Developing and implementing a culture of continuous improvement and openness to feedback at all organizational levels.\tDeveloping policies and procedures for managing changes based on feedback. Leading and mentoring teams in constructive interaction and adapting to changes. Knowledge base and employee training\tParticipation in the creation and updating of project documentation, including user manuals, frequently asked questions, and basic instructions. Collecting feedback from users and colleagues to improve existing materials. Assisting in organizing internal training.\tDeveloping and supporting specialized sections in the knowledge base, focused on specific aspects of working with Salesforce and DevOps practices. Conducting introductory sessions for new employees on using tools and processes. Participating in creating educational materials and cases.\tOrganizing and conducting specialized trainings and workshops for the team, dedicated to new technologies, methodologies, and best practices in DevOps and working with Salesforce. Curating and updating sections of the knowledge base related to complex technical issues and best practices.\tDeveloping and implementing a strategy for training and skill development within the team, including planning educational events and evaluating their effectiveness.\tDetermining overall goals and strategies for continuous learning and team development in line with current and future project needs. Developing policies and procedures for knowledge management in the organization. Assessing the contribution of training programs to achieving business goals.\tStrategic planning and leading initiatives to create a corporate culture of continuous learning and self-development. Implementing innovative approaches to training and development, including the use of AI and machine learning for personalized learning. Managing budgets and resources for educational programs. Developing partnerships with educational institutions and organisations for knowledge and experience exchange.","keywords":"","version":"Next"},{"title":"Applications","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Useful materials/99_02_recommended_applications","content":"Applications Meld (Meld is a visual diff and merge tool targeted at developers) - link Workbench (multifunctional solutions for working with environments) - link Perm-comparator (Compare Salesforce.com Users, Profiles, and Permission Sets) - link Multi-highlight (for chrome) - link Grammarly (for chrome) - link Salesforce inspector (for chrome) - link","keywords":"","version":"Next"},{"title":"Responsibility","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/01_02_02_Responsibility_Delivery_Manager","content":"Responsibility info The higher level inherits the responsibilities of the previous levels. Responsibility levels are not fixed. Duties can change depending on the project and company. It's important to consider the individual skills and experience of specialists. Grade\tJunior\tJunior+\tMiddle\tMiddle+\tSenior\tLeadProject Management and Lifecycle\tParticipation in project planning and initiation under the guidance of more experienced colleagues.Assisting in defining and controlling project timelines, budget, and resources.Performing simple tasks related to project planning and time management.\tIndependently performing some tasks related to planning and managing projects with limited complexity under supervision.Supporting monitoring and controlling project timelines, budget, and resources.Taking a more active role in planning and managing project timelines, including developing detailed plans and schedules.\tIndependently planning and managing projects from initiation to closure for projects of medium complexity.Controlling project timelines, budget, and resources.Full responsibility for planning and managing project timelines, including task coordination between teams.\tIndependently planning and managing most aspects of the project.Defining and controlling timelines, budget, and resources for complex projects.Communicating with clients and stakeholders.Solving complex tasks and conflicts.\tPlanning and managing large and complex projects from initiation to closure.Leading the project team.Full responsibility for strategic planning and timeline management, including developing long-term plans and strategies.\tLeading and strategically managing a portfolio of projects, including multi-component and cross-functional projects.Developing and implementing planning and timeline management strategies for the entire organization, including process optimization and best practice implementation. Coordination and Team Management\tSupporting team management under the guidance of more experienced managers.Participating in the professional development of team members.Performing simple tasks to track progress.\tIndependently performing some tasks related to forming and managing teams.Supporting efficient interaction between teams with minimal supervision.Actively participating in ensuring tasks are completed on time and within budget.\tIndependently forming and managing development, testing, and deployment teams.Ensuring effective interaction between teams for medium complexity projects.Full responsibility for the timely and budget-compliant completion of tasks by the team.Participating in the development and support of team members' professional growth.\tWorking on complex projects.Ensuring effective team collaboration and communication.Resolving conflicts and issues within the team.Mentoring and supporting team members.\tDeveloping and implementing team management strategies.Overseeing the execution of a project portfolio.Communicating with senior management.\tLeading the Delivery Manager team.Developing and implementing programs for professional skills development and career growth within the organization.Developing and implementing strategies for ensuring effective interaction between teams at the organizational level. Monitoring and Change Management in Project Environments\tSetting up basic dashboards and alerts based on provided configurations and templates.Assisting in developing and implementing change management strategies.Logging and escalating incidents.\tAnalyzing monitoring data to identify trends and potential problems.Proposing solutions to improve performance and stability of project environments.Participating in discussions and planning changes in project environments.\tDeveloping and implementing simple change management strategies.Setting up and optimizing monitoring systems for more accurate and effective performance tracking of project environments.Collaborating with DevOps and other technical teams to coordinate changes.\tImplementing new monitoring systems and ensuring their security.Ensuring the reliability of monitoring systems and their compliance with security standards.Coordinating and managing change processes to minimize disruptions and downtime.\tDeveloping and implementing a strategy for monitoring project environments and managing changes.Communicating with senior management.\tLeading the overall monitoring and change management system at the organizational level.Conducting strategic planning and development of monitoring and change management systems.Managing risks and responding to incidents at the organizational level. Quality Control and Risk Management\tSupporting adherence to quality standards at all project stages under the guidance of more experienced colleagues.Logging and escalating identified risks and issues.Participating in routine quality monitoring and reporting.\tAnalyzing quality data and metrics to identify potential problems and deviations.Participating in the development and implementation of quality management plans.Participating in internal quality audits and risk management.\tIndependently ensuring adherence to quality standards at all project stages.Developing and implementing quality control procedures and managing their execution.Managing simple project risks.Maintaining regular quality and risk reports, presenting reports to management.\tOptimizing existing quality control procedures and risk management to improve efficiency.Analyzing complex quality issues and risks, developing strategies to address them.\tDeveloping comprehensive quality control and risk management strategies for complex projects.Leading initiatives to enhance quality and mitigate risks across multiple projects.Reporting to senior management on quality and risk metrics.\tLeading organizational quality control and risk management efforts.Implementing enterprise-wide quality standards and risk mitigation strategies.Overseeing risk management and quality assurance programs across the organization.Engaging with executive leadership to align quality and risk objectives with business goals. Optimization and Automation of Delivery\tParticipating in basic tasks for automating delivery processes under the guidance of more experienced colleagues.Supporting the optimization of existing delivery processes to improve efficiency.Maintaining the reliability of processes.\tAnalyzing current delivery processes to identify opportunities for automation and optimization.Independently performing tasks related to the automation and optimization of delivery processes.Testing new automated processes.\tIndependently developing and implementing automated delivery processes.Optimizing processes to enhance their technical efficiency and reliability.Collaborating with development and operations support teams to coordinate automation initiatives.\tDeveloping, implementing, and optimizing complex automated processes.Evaluating and implementing best practices and standards of automation in delivery processes.Documenting automation and optimization processes.\tMaking key decisions on automation architecture and strategy.Leading large-scale projects for the automation and optimization of delivery processes.Developing and implementing automation and optimization strategies at the organizational level.\tOverseeing the execution of all projects.Communicating with senior management.Managing risks associated with the automation and optimization of delivery processes. Release Management, Strategy Development and Implementation\tParticipating in the setup and support of existing release processes and the use of Git.Logging and escalating issues related to releases and versions.\tIndependently performing some tasks related to developing release management strategies.Analyzing current release processes and the use of Git to identify improvement opportunities.Supporting the development and implementation of small improvements in release processes.\tDeveloping and implementing strategies for the use of Git and release processes to ensure efficient deployment of updates and new features.Developing, implementing, and optimizing simple release management strategies.Documenting release management processes.\tAnalyzing and resolving complex issues related to release processes and the use of Git.Managing communications with stakeholders regarding releases.Ensuring the integration of release processes with other organizational systems and tools.\tDeveloping and implementing organization-wide release management strategies.Implementing best practices and standards for release management.Making key decisions on release and Git strategy and architecture.\tOverseeing the execution of all projects.Communicating with senior management.Managing risks associated with releases and the use of Git. Project Progress Monitoring and Reporting\tPerforming routine tasks for data collection and project progress monitoring.Logging and escalating identified issues and deviations.Assisting in preparing project progress reports for stakeholders.\tIndependently performing some tasks related to project progress monitoring.Participating in discussions and providing suggestions for process improvements based on data analysis.\tRegularly monitoring project progress, including key performance indicators (KPIs).Independently preparing and presenting project progress reports to stakeholders.Analyzing project metrics and developing recommendations for process improvements and addressing identified issues.Documenting monitoring and reporting processes.\tDeveloping and implementing project progress monitoring systems to enhance accuracy and efficiency.Leading initiatives to improve monitoring and reporting processes.Analyzing complex issues and providing strategic recommendations to improve project performance.\tDeveloping and implementing organizational-level project progress monitoring strategies.Ensuring the integration of monitoring systems with other project management tools.Making key decisions regarding the structure and content of project progress reports.\tManaging large initiatives to improve monitoring and reporting processes.Communicating with senior management.Managing risks associated with project monitoring and reporting. Knowledge Management\tAssisting in collecting and documenting information for the project's knowledge base.Supporting the organization and updating of the knowledge base under the guidance of more experienced colleagues.\tIndependently creating and documenting simple project knowledge.Participating in the development of a knowledge management system.Participating in knowledge transfer processes within the team.\tCreating and maintaining a structured project knowledge base.Ensuring the documentation is up-to-date and accessible to all team members.Developing and implementing procedures for efficient knowledge storage and transfer within the team.Organizing regular training sessions and facilitating knowledge sharing among team members.\tImplementing best practices and technologies for knowledge management in the project.Analyzing complex knowledge management issues and developing solutions to address them.\tEvaluating and implementing advanced technologies and methods to improve knowledge management.Developing and implementing organization-wide knowledge management strategies.Ensuring the integration of knowledge management systems with other corporate systems.\tManaging large initiatives to improve knowledge management processes and their integration with other corporate systems.Overseeing the execution of all projects.Communicating with senior management. Communication and Feedback Management\tSupporting the collection and documentation of feedback from the team and the client.Logging and escalating identified issues and suggestions from the team and client.Assisting colleagues in ensuring communication among project participants.\tIndependently conducting simple meetings and sessions.Analyzing current communication processes and suggesting improvements.Participating in the development of an action plan for improvements.\tEnsuring regular and effective communication among all project participants.Independently collecting and analyzing feedback from the team and client.\tConducting deep analysis of complex issues related to communication and feedback, and developing solutions to address them.Documenting communication and feedback processes.Ensuring the integration of communication processes with other management and operational systems.\tLeading initiatives to improve communication processes and implementing changes based on feedback.Making key decisions regarding the structure and content of communication processes and systems.Evaluating and implementing advanced methods and technologies to enhance communication processes and feedback management.\tCommunicating with senior management.Ensuring regular analysis and reporting on the effectiveness of communication and implemented changes.Engaging in strategic planning and development of communication and feedback management systems at the organizational level.","keywords":"","version":"Next"},{"title":"Events","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Useful materials/99_04_Events","content":"Events","keywords":"","version":"Next"},{"title":"The Role of a Delivery Manager","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102","content":"","keywords":"","version":"Next"},{"title":"Why a Delivery Manager is Needed​","type":1,"pageTitle":"The Role of a Delivery Manager","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102#why-a-delivery-manager-is-needed","content":" Ensuring agile approaches to project management and product delivery.Responsibility for delivering the project from start to finish, including planning, monitoring, and reporting.Facilitating communication between stakeholders, development teams, and customers, ensuring everyone is aligned and informed.Ensuring flexibility and scalability of value delivery processes in response to business changes.Prioritising tasks and features based on their value to the customer, maximizing the impact of each project iteration.  ","version":"Next","tagName":"h2"},{"title":"What a Delivery Manager Does​","type":1,"pageTitle":"The Role of a Delivery Manager","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102#what-a-delivery-manager-does","content":" The core responsibility of a Delivery Manager is to oversee the entire delivery lifecycle, fostering a collaborative environment that leads to successful project outcomes. Here are some key areas they focus on:  Project Management with Agile MethodologyCoordination of Development Teams and Resource ManagementMonitoring Project Progress and QualityRisk ManagementTeam Coaching and Facilitation  ","version":"Next","tagName":"h2"},{"title":"How a Delivery Manager Works​","type":1,"pageTitle":"The Role of a Delivery Manager","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102#how-a-delivery-manager-works","content":" To achieve their goals, a Delivery Manager takes on several roles and responsibilities, including project manager, change agent, team coordinator, and mentor.  ","version":"Next","tagName":"h2"},{"title":"The Project Manager​","type":1,"pageTitle":"The Role of a Delivery Manager","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102#the-project-manager","content":" As a project manager, they are responsible for planning, executing, and monitoring projects, utilising agile methodologies for flexible and efficient operation.  ","version":"Next","tagName":"h3"},{"title":"The Change Agent​","type":1,"pageTitle":"The Role of a Delivery Manager","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102#the-change-agent","content":" As a change agent, they facilitate the adoption of agile practices within teams and the organisation, adapting processes to changing conditions and requirements.  ","version":"Next","tagName":"h3"},{"title":"The Team Coordinator​","type":1,"pageTitle":"The Role of a Delivery Manager","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102#the-team-coordinator","content":" They ensure team alignment and manage communications and resources to ensure projects are completed on time and meet customer expectations.  ","version":"Next","tagName":"h3"},{"title":"The Mentor​","type":1,"pageTitle":"The Role of a Delivery Manager","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_02_Delivery_Manager/index0102#the-mentor","content":" The Delivery Manager helps in developing team skills, conducting training and mentoring to increase efficiency and adaptability to agile methodologies. ","version":"Next","tagName":"h3"},{"title":"Metrics and KPIs","type":0,"sectionRef":"#","url":"/SFITDelivery-KnowledgeHub/docs/Roles/01_04_Metrics_and_KPIs","content":"Metrics and KPIs info Properly selected metrics for a project allow for accurate and qualitative assessment of the project and its processes, leading to improvements. Incorrectly selected metrics, at best, will not help the project, and at worst, will lead to loss of control over the project. It is important not to seek a silver bullet or blindly copy others' metrics. This list displays the most commonly encountered basic metrics, their meanings, and areas of application. #\tName\tDescription and Notes\tDevOps\tDelivery Manager1\tDeployment Time\t- Description: The time taken to deploy a release or other change to the target environment or production. - Notes: It can be calculated separately for release deployments, other changes, and for selected environments.\t+ 2\tDeployment Frequency\t- Description: The number of deployments over a certain period (e.g., per week or month). - Notes: The usefulness of the metric depends on business requirements and project architecture. The most effective strategy is on-demand delivery.\t+ 3\tDeployment Success Rate (Change Failure Rate)\t- Description: The percentage of deployments that go without errors or failures. - Notes: The team should agree on what constitutes a failure. This metric helps assess project processes. Deployment Success Rate is the opposite of Change Failure Rate.\t+ 4\tMean Time to Recovery (MTTR)\t- Description: The average time required to restore the system after a failure. - Notes: An important aspect of this metric is recording the time of failure and determining when the failure is logged.\t+ 5\tIncident Response Time\t- Description: The time taken to respond to incidents from the moment they occur. - Notes: A measure of the team's effectiveness in responding to issues and incidents.\t+\t+ 6\tMean Time Between Failures (MTBF)\t- Description: The average time between failures, calculated as the operating time divided by the number of failures. - Notes: Helps identify architectural weaknesses and often works in conjunction with MTTR.\t+ 7\tTest Automation Coverage\t- Description: The proportion of automated tests out of the total number of tests. - Notes: Besides the automation ratio, it's important to consider the prioritization of cases.\t+ 8\tTest Coverage Percentage\t- Description: The assessment of code coverage by tests. - Notes: It is necessary to agree with the teams on the coverage percentage to be adopted in the project, usually ranging from 80% to 90%.\t+ 9\tStakeholders Satisfaction Rate\t- Description: The assessments of developers' and other CI/CD or end-to-end processes team members' satisfaction. - Notes: It is necessary to identify who the CI/CD and end-to-end processes stakeholders are in the project and to regularly work with their feedback.\t+\t+ 10\tFlow Efficiency\t- Description: The percentage of time during which work is actually performed compared to the total time a task spends in the process. - Notes: This metric is highly sensitive to CI/CD process automation and demonstrates the efficiency of end-to-end processes..\t+\t+ 11\tLead Time\t- Description: The time elapsed from task assignment to its deployment in production. - Notes: This metric serves as an indicator of process quality and helps identify bottlenecks slowing down delivery.\t+\t+ 12\tCycle Time\t- Description: The time taken from the start of task development to its delivery. - Notes: This metric indicates process quality and helps identify development and delivery bottlenecks slowing down work.\t+\t+ 13\tOn-time Delivery Rate\t- Description: The percentage of projects or tasks completed within the set deadlines. - Notes: An important indicator for assessing a manager's ability to manage timelines and adhere to schedules. + 14\tBudget Adherence\t- Description: The percentage of projects completed within the allocated budget. - Notes: An assessment of a manager's ability to effectively manage the project's financial resources. + 15\tDelivery Quality\t- Description: An assessment of the quality of the delivered product or service, based on customer feedback and the number of defects. - Notes: A key indicator of customer satisfaction with product quality. + 16\tCommunication Efficiency\t- Description: The level of team and customer satisfaction with communication efficiency. - Notes: An important aspect for ensuring transparency and coordination among all project participants. + 17\tRisk Management Efficiency\t- Description: An assessment of the effectiveness of risk management, including the number of identified and successfully mitigated risks. - Notes: Important for understanding how well the team can anticipate and manage potential problems. + 18\tResource Utilization Rate\t- Description: The percentage of available resources (human, technical, and financial) utilized in the project. - Notes: Helps determine how efficiently resources are being used. + 19\tScope Changes\t- Description: The number and impact of changes to the project's scope. - Notes: Important to monitor how frequently and significantly the project scope changes. + 20\tTeam Satisfaction\t- Description: The level of team members' satisfaction with the project and working conditions. - Notes: High team satisfaction contributes to improved productivity and reduced turnover. +","keywords":"","version":"Next"}],"options":{"id":"default"}}